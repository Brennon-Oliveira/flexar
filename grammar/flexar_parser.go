// Code generated from ./grammar/Flexar.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Flexar

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type FlexarParser struct {
	*antlr.BaseParser
}

var FlexarParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func flexarParserInit() {
	staticData := &FlexarParserStaticData
	staticData.LiteralNames = []string{
		"", "'import'", "'namespace'", "'export'", "'use'", "'as'", "", "'this'",
		"'new'", "'enum'", "'struct'", "'func'", "'class'", "'interface'", "'extends'",
		"'implements'", "'public'", "'private'", "'protected'", "'static'",
		"'abstract'", "'final'", "'override'", "'if'", "'else'", "'elif'", "'switch'",
		"'case'", "'default'", "'while'", "'do'", "'for'", "'break'", "'continue'",
		"'return'", "'const'", "'readonly'", "'in'", "'is'", "'try'", "'catch'",
		"'finally'", "'int'", "'int8'", "'int16'", "'int32'", "'int64'", "'uint'",
		"'uint8'", "'uint16'", "'uint32'", "'uint64'", "'float'", "'float32'",
		"'float64'", "'bool'", "'char'", "'string'", "'INF'", "'tuple'", "'map'",
		"'error'", "'null'", "'any'", "'dyn'", "", "", "'_'", "", "','", "'.'",
		"':'", "'::'", "'->'", "';'", "'('", "')'", "'{'", "'}'", "'['", "']'",
		"'='", "'+='", "'-='", "'*='", "'%='", "'/='", "'**='", "'&='", "'|='",
		"'^='", "'<<='", "'>>='", "':='", "'=='", "'!='", "'<'", "'<='", "'>'",
		"'>='", "'&&'", "'||'", "'^^'", "'!'", "'&'", "'|'", "'^'", "'~'", "'<<'",
		"'>>'", "'+'", "'-'", "'*'", "'**'", "'%'", "'/'", "'++'", "'--'", "'?'",
		"'..'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "IMPORT", "NAMESPACE", "EXPORT", "USE", "AS", "BOOLEAN", "THIS",
		"NEW", "ENUM", "STRUCT", "FUNC", "CLASS", "INTERFACE", "EXTENDS", "IMPLEMENTS",
		"PUBLIC", "PRIVATE", "PROTECTED", "STATIC", "ABSTRACT", "FINAL", "OVERRIDE",
		"IF", "ELSE", "ELIF", "SWITCH", "CASE", "DEFAULT", "WHILE", "DO", "FOR",
		"BREAK", "CONTINUE", "RETURN", "CONST", "READONLY", "IN", "IS", "TRY",
		"CATCH", "FINALLY", "INT", "INT8", "INT16", "INT32", "INT64", "UINT",
		"UINT8", "UINT16", "UINT32", "UINT64", "FLOAT", "FLOAT32", "FLOAT64",
		"BOOL", "CHAR", "STRING", "INF", "TUPLE", "MAP", "ERROR", "NULL", "ANY",
		"DYN", "TEMPLATE_STRING", "DEFAULT_STRING", "DISCARD", "NAME", "COMMA",
		"DOT", "COLON", "DOUBLE_COLON", "ARROW", "SEMICOLON", "OPEN_PAREN",
		"CLOSE_PAREN", "OPEN_BRACE", "CLOSE_BRACE", "OPEN_BRACKET", "CLOSE_BRACKET",
		"ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "STAR_ASSIGN", "MODULE_ASSIGN",
		"DIV_ASSIGN", "EXP_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN",
		"SHL_ASSIGN", "SHR_ASSIGN", "INF_ASSIGN", "EQUAL", "NOT_EQUAL", "LESS",
		"LESS_EQUAL", "GREATER", "GREATER_EQUAL", "AND", "OR", "XOR", "NOT",
		"BIT_AND", "BIT_OR", "BIT_XOR", "BIT_NOT", "SHL", "SHR", "PLUS", "MINUS",
		"STAR", "EXP", "MODULE", "DIV", "INC", "DEC", "QUESTION", "RANGE", "SPREAD",
		"INT_NUM", "FLOAT_NUM", "COMMENT", "WS",
	}
	staticData.RuleNames = []string{
		"program", "program_rule", "import_group", "import_rule", "import_namespace",
		"namespace_name", "namespace", "namespace_call", "class", "class_extends",
		"class_implements", "class_body", "class_attribute", "privacy_modifier",
		"class_method", "abstract_method", "class_modifier", "constructor",
		"class_new_instance", "method_call", "attribute_call", "interface",
		"interface_extends", "interface_body", "interface_body_rule", "interface_method",
		"interface_attribute", "struct", "struct_body", "struct_attribute",
		"enum", "enum_body", "enum_attribute", "expression", "composed_value",
		"list_value", "map_value", "tuple_value", "named_tuple_value", "and_expression",
		"or_expression", "xor_expression", "not_expression", "expression_math",
		"term_math", "factor_math", "bitwise_math", "shift_math", "unary_math",
		"before_unary", "after_unary", "math_value", "parenthesis_expression",
		"bitwise_operator", "shift_operator", "term_operator", "factor_operator",
		"comparision_operator", "value", "statement", "new_scope", "for_statement",
		"for_rule", "for_in", "full_for", "while_statement", "do_while_statement",
		"switch_statement", "switch_case", "try_statement", "catch_statement",
		"finally_statement", "if_statement", "elif_statement", "else_statement",
		"struct_func", "func", "anonymous_func", "func_param", "func_callback",
		"func_param_callback", "func_param_rule", "func_call", "func_call_params",
		"func_return", "func_body", "return_statement", "variable_declaration",
		"variable_assign", "variable_name", "assing", "type", "final_type",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 124, 1116, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 1, 0, 5, 0, 188, 8,
		0, 10, 0, 12, 0, 191, 9, 0, 1, 0, 1, 0, 5, 0, 195, 8, 0, 10, 0, 12, 0,
		198, 9, 0, 1, 1, 3, 1, 201, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3,
		1, 209, 8, 1, 1, 2, 1, 2, 1, 2, 1, 3, 3, 3, 215, 8, 3, 1, 3, 1, 3, 1, 3,
		3, 3, 220, 8, 3, 1, 3, 3, 3, 223, 8, 3, 5, 3, 225, 8, 3, 10, 3, 12, 3,
		228, 9, 3, 1, 3, 1, 3, 4, 3, 232, 8, 3, 11, 3, 12, 3, 233, 1, 4, 1, 4,
		1, 4, 3, 4, 239, 8, 4, 1, 4, 1, 4, 3, 4, 243, 8, 4, 1, 5, 1, 5, 1, 5, 5,
		5, 248, 8, 5, 10, 5, 12, 5, 251, 9, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1,
		7, 3, 7, 259, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 264, 8, 7, 1, 8, 3, 8, 267,
		8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 272, 8, 8, 1, 8, 3, 8, 275, 8, 8, 1, 8, 1,
		8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 285, 8, 9, 10, 9, 12, 9, 288,
		9, 9, 1, 9, 3, 9, 291, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		5, 10, 299, 8, 10, 10, 10, 12, 10, 302, 9, 10, 1, 10, 3, 10, 305, 8, 10,
		1, 11, 1, 11, 5, 11, 309, 8, 11, 10, 11, 12, 11, 312, 9, 11, 1, 11, 5,
		11, 315, 8, 11, 10, 11, 12, 11, 318, 9, 11, 1, 11, 5, 11, 321, 8, 11, 10,
		11, 12, 11, 324, 9, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 337, 8, 14, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 3, 15, 344, 8, 15, 1, 15, 1, 15, 3, 15, 348, 8, 15, 1, 16, 3,
		16, 351, 8, 16, 1, 16, 3, 16, 354, 8, 16, 1, 16, 3, 16, 357, 8, 16, 1,
		16, 3, 16, 360, 8, 16, 1, 16, 3, 16, 363, 8, 16, 1, 17, 3, 17, 366, 8,
		17, 1, 17, 1, 17, 1, 17, 3, 17, 371, 8, 17, 1, 17, 1, 17, 1, 17, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5,
		18, 387, 8, 18, 10, 18, 12, 18, 390, 9, 18, 3, 18, 392, 8, 18, 1, 18, 3,
		18, 395, 8, 18, 1, 19, 1, 19, 3, 19, 399, 8, 19, 1, 19, 1, 19, 1, 19, 1,
		20, 1, 20, 3, 20, 406, 8, 20, 1, 20, 1, 20, 1, 20, 5, 20, 411, 8, 20, 10,
		20, 12, 20, 414, 9, 20, 1, 21, 1, 21, 1, 21, 3, 21, 419, 8, 21, 1, 21,
		1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 429, 8, 22, 10,
		22, 12, 22, 432, 9, 22, 1, 22, 3, 22, 435, 8, 22, 1, 23, 1, 23, 5, 23,
		439, 8, 23, 10, 23, 12, 23, 442, 9, 23, 1, 23, 1, 23, 1, 24, 1, 24, 3,
		24, 448, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 454, 8, 25, 1, 25, 1,
		25, 3, 25, 458, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27,
		1, 27, 1, 28, 1, 28, 5, 28, 470, 8, 28, 10, 28, 12, 28, 473, 9, 28, 1,
		28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 5, 31,
		485, 8, 31, 10, 31, 12, 31, 488, 9, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1,
		32, 3, 32, 495, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 510, 8, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 518, 8, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 5, 33, 536, 8, 33, 10, 33, 12, 33, 539, 9, 33, 1, 34,
		1, 34, 1, 34, 1, 34, 3, 34, 545, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 5,
		35, 551, 8, 35, 10, 35, 12, 35, 554, 9, 35, 3, 35, 556, 8, 35, 1, 35, 1,
		35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36,
		569, 8, 36, 10, 36, 12, 36, 572, 9, 36, 3, 36, 574, 8, 36, 1, 36, 1, 36,
		1, 37, 1, 37, 1, 37, 1, 37, 5, 37, 582, 8, 37, 10, 37, 12, 37, 585, 9,
		37, 3, 37, 587, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38,
		1, 38, 1, 38, 1, 38, 5, 38, 599, 8, 38, 10, 38, 12, 38, 602, 9, 38, 3,
		38, 604, 8, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		5, 39, 614, 8, 39, 10, 39, 12, 39, 617, 9, 39, 1, 40, 1, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 5, 40, 625, 8, 40, 10, 40, 12, 40, 628, 9, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 636, 8, 41, 10, 41, 12, 41, 639,
		9, 41, 1, 42, 1, 42, 1, 42, 3, 42, 644, 8, 42, 1, 43, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 43, 5, 43, 653, 8, 43, 10, 43, 12, 43, 656, 9, 43,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 665, 8, 44, 10,
		44, 12, 44, 668, 9, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45,
		676, 8, 45, 10, 45, 12, 45, 679, 9, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 5, 46, 688, 8, 46, 10, 46, 12, 46, 691, 9, 46, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 700, 8, 47, 10, 47, 12,
		47, 703, 9, 47, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 709, 8, 48, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 717, 8, 49, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 725, 8, 50, 1, 51, 1, 51, 3, 51, 729, 8, 51,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 55, 1, 55, 1,
		56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 759, 8, 59, 1,
		60, 1, 60, 5, 60, 763, 8, 60, 10, 60, 12, 60, 766, 9, 60, 1, 60, 1, 60,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 776, 8, 61, 10, 61, 12,
		61, 779, 9, 61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 785, 8, 62, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 3, 64, 796, 8, 64,
		1, 64, 1, 64, 3, 64, 800, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 5, 65, 808, 8, 65, 10, 65, 12, 65, 811, 9, 65, 1, 65, 1, 65, 1, 66,
		1, 66, 1, 66, 5, 66, 818, 8, 66, 10, 66, 12, 66, 821, 9, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67,
		5, 67, 835, 8, 67, 10, 67, 12, 67, 838, 9, 67, 1, 67, 1, 67, 1, 68, 1,
		68, 1, 68, 1, 68, 5, 68, 846, 8, 68, 10, 68, 12, 68, 849, 9, 68, 1, 68,
		1, 68, 1, 68, 5, 68, 854, 8, 68, 10, 68, 12, 68, 857, 9, 68, 3, 68, 859,
		8, 68, 1, 69, 1, 69, 1, 69, 5, 69, 864, 8, 69, 10, 69, 12, 69, 867, 9,
		69, 1, 69, 1, 69, 3, 69, 871, 8, 69, 1, 69, 3, 69, 874, 8, 69, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 884, 8, 70, 10, 70,
		12, 70, 887, 9, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 5, 71, 894, 8, 71,
		10, 71, 12, 71, 897, 9, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 5, 72, 907, 8, 72, 10, 72, 12, 72, 910, 9, 72, 1, 72, 1, 72,
		5, 72, 914, 8, 72, 10, 72, 12, 72, 917, 9, 72, 1, 72, 3, 72, 920, 8, 72,
		1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 928, 8, 73, 10, 73, 12,
		73, 931, 9, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 5, 74, 938, 8, 74, 10,
		74, 12, 74, 941, 9, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 3, 75, 948,
		8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 958,
		8, 76, 1, 76, 1, 76, 3, 76, 962, 8, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1,
		77, 3, 77, 969, 8, 77, 1, 77, 1, 77, 3, 77, 973, 8, 77, 1, 77, 1, 77, 1,
		77, 1, 78, 1, 78, 1, 78, 5, 78, 981, 8, 78, 10, 78, 12, 78, 984, 9, 78,
		1, 79, 1, 79, 1, 79, 3, 79, 989, 8, 79, 1, 79, 1, 79, 3, 79, 993, 8, 79,
		1, 80, 1, 80, 1, 80, 5, 80, 998, 8, 80, 10, 80, 12, 80, 1001, 9, 80, 1,
		81, 1, 81, 3, 81, 1005, 8, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1010, 8, 81,
		1, 81, 1, 81, 3, 81, 1014, 8, 81, 1, 82, 1, 82, 1, 82, 3, 82, 1019, 8,
		82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 5, 83, 1026, 8, 83, 10, 83, 12,
		83, 1029, 9, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1036, 8, 84,
		10, 84, 12, 84, 1039, 9, 84, 1, 84, 1, 84, 3, 84, 1043, 8, 84, 1, 85, 1,
		85, 5, 85, 1047, 8, 85, 10, 85, 12, 85, 1050, 9, 85, 1, 85, 3, 85, 1053,
		8, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 1061, 8, 86, 10,
		86, 12, 86, 1064, 9, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87,
		1072, 8, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1,
		89, 3, 89, 1083, 8, 89, 1, 90, 1, 90, 1, 91, 3, 91, 1088, 8, 91, 1, 91,
		1, 91, 1, 91, 1, 91, 3, 91, 1094, 8, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1,
		91, 3, 91, 1101, 8, 91, 1, 91, 1, 91, 1, 91, 5, 91, 1106, 8, 91, 10, 91,
		12, 91, 1109, 9, 91, 1, 91, 3, 91, 1112, 8, 91, 1, 92, 1, 92, 1, 92, 0,
		9, 66, 78, 80, 82, 86, 88, 90, 92, 94, 93, 0, 2, 4, 6, 8, 10, 12, 14, 16,
		18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
		54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
		90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
		152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
		182, 184, 0, 12, 1, 0, 16, 18, 2, 0, 20, 20, 22, 22, 1, 0, 104, 106, 1,
		0, 108, 109, 2, 0, 112, 112, 114, 115, 1, 0, 110, 111, 1, 0, 94, 99, 3,
		0, 6, 6, 65, 66, 121, 122, 1, 0, 67, 68, 1, 0, 81, 93, 3, 0, 64, 64, 68,
		68, 121, 121, 2, 0, 42, 63, 68, 68, 1182, 0, 189, 1, 0, 0, 0, 2, 200, 1,
		0, 0, 0, 4, 210, 1, 0, 0, 0, 6, 231, 1, 0, 0, 0, 8, 235, 1, 0, 0, 0, 10,
		244, 1, 0, 0, 0, 12, 252, 1, 0, 0, 0, 14, 258, 1, 0, 0, 0, 16, 266, 1,
		0, 0, 0, 18, 278, 1, 0, 0, 0, 20, 292, 1, 0, 0, 0, 22, 306, 1, 0, 0, 0,
		24, 327, 1, 0, 0, 0, 26, 330, 1, 0, 0, 0, 28, 336, 1, 0, 0, 0, 30, 338,
		1, 0, 0, 0, 32, 350, 1, 0, 0, 0, 34, 365, 1, 0, 0, 0, 36, 375, 1, 0, 0,
		0, 38, 398, 1, 0, 0, 0, 40, 405, 1, 0, 0, 0, 42, 415, 1, 0, 0, 0, 44, 422,
		1, 0, 0, 0, 46, 436, 1, 0, 0, 0, 48, 447, 1, 0, 0, 0, 50, 449, 1, 0, 0,
		0, 52, 459, 1, 0, 0, 0, 54, 463, 1, 0, 0, 0, 56, 467, 1, 0, 0, 0, 58, 476,
		1, 0, 0, 0, 60, 478, 1, 0, 0, 0, 62, 482, 1, 0, 0, 0, 64, 491, 1, 0, 0,
		0, 66, 517, 1, 0, 0, 0, 68, 544, 1, 0, 0, 0, 70, 546, 1, 0, 0, 0, 72, 559,
		1, 0, 0, 0, 74, 577, 1, 0, 0, 0, 76, 590, 1, 0, 0, 0, 78, 607, 1, 0, 0,
		0, 80, 618, 1, 0, 0, 0, 82, 629, 1, 0, 0, 0, 84, 643, 1, 0, 0, 0, 86, 645,
		1, 0, 0, 0, 88, 657, 1, 0, 0, 0, 90, 669, 1, 0, 0, 0, 92, 680, 1, 0, 0,
		0, 94, 692, 1, 0, 0, 0, 96, 708, 1, 0, 0, 0, 98, 716, 1, 0, 0, 0, 100,
		724, 1, 0, 0, 0, 102, 728, 1, 0, 0, 0, 104, 730, 1, 0, 0, 0, 106, 734,
		1, 0, 0, 0, 108, 736, 1, 0, 0, 0, 110, 738, 1, 0, 0, 0, 112, 740, 1, 0,
		0, 0, 114, 742, 1, 0, 0, 0, 116, 744, 1, 0, 0, 0, 118, 758, 1, 0, 0, 0,
		120, 760, 1, 0, 0, 0, 122, 769, 1, 0, 0, 0, 124, 784, 1, 0, 0, 0, 126,
		786, 1, 0, 0, 0, 128, 792, 1, 0, 0, 0, 130, 801, 1, 0, 0, 0, 132, 814,
		1, 0, 0, 0, 134, 828, 1, 0, 0, 0, 136, 858, 1, 0, 0, 0, 138, 860, 1, 0,
		0, 0, 140, 875, 1, 0, 0, 0, 142, 890, 1, 0, 0, 0, 144, 900, 1, 0, 0, 0,
		146, 921, 1, 0, 0, 0, 148, 934, 1, 0, 0, 0, 150, 944, 1, 0, 0, 0, 152,
		953, 1, 0, 0, 0, 154, 965, 1, 0, 0, 0, 156, 977, 1, 0, 0, 0, 158, 985,
		1, 0, 0, 0, 160, 994, 1, 0, 0, 0, 162, 1002, 1, 0, 0, 0, 164, 1015, 1,
		0, 0, 0, 166, 1022, 1, 0, 0, 0, 168, 1042, 1, 0, 0, 0, 170, 1044, 1, 0,
		0, 0, 172, 1056, 1, 0, 0, 0, 174, 1065, 1, 0, 0, 0, 176, 1073, 1, 0, 0,
		0, 178, 1082, 1, 0, 0, 0, 180, 1084, 1, 0, 0, 0, 182, 1111, 1, 0, 0, 0,
		184, 1113, 1, 0, 0, 0, 186, 188, 3, 4, 2, 0, 187, 186, 1, 0, 0, 0, 188,
		191, 1, 0, 0, 0, 189, 187, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190, 192,
		1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 192, 196, 3, 12, 6, 0, 193, 195, 3, 2,
		1, 0, 194, 193, 1, 0, 0, 0, 195, 198, 1, 0, 0, 0, 196, 194, 1, 0, 0, 0,
		196, 197, 1, 0, 0, 0, 197, 1, 1, 0, 0, 0, 198, 196, 1, 0, 0, 0, 199, 201,
		5, 3, 0, 0, 200, 199, 1, 0, 0, 0, 200, 201, 1, 0, 0, 0, 201, 208, 1, 0,
		0, 0, 202, 209, 3, 16, 8, 0, 203, 209, 3, 152, 76, 0, 204, 209, 3, 42,
		21, 0, 205, 209, 3, 54, 27, 0, 206, 209, 3, 150, 75, 0, 207, 209, 3, 60,
		30, 0, 208, 202, 1, 0, 0, 0, 208, 203, 1, 0, 0, 0, 208, 204, 1, 0, 0, 0,
		208, 205, 1, 0, 0, 0, 208, 206, 1, 0, 0, 0, 208, 207, 1, 0, 0, 0, 209,
		3, 1, 0, 0, 0, 210, 211, 5, 1, 0, 0, 211, 212, 3, 6, 3, 0, 212, 5, 1, 0,
		0, 0, 213, 215, 5, 4, 0, 0, 214, 213, 1, 0, 0, 0, 214, 215, 1, 0, 0, 0,
		215, 216, 1, 0, 0, 0, 216, 226, 3, 8, 4, 0, 217, 219, 5, 69, 0, 0, 218,
		220, 5, 4, 0, 0, 219, 218, 1, 0, 0, 0, 219, 220, 1, 0, 0, 0, 220, 222,
		1, 0, 0, 0, 221, 223, 3, 8, 4, 0, 222, 221, 1, 0, 0, 0, 222, 223, 1, 0,
		0, 0, 223, 225, 1, 0, 0, 0, 224, 217, 1, 0, 0, 0, 225, 228, 1, 0, 0, 0,
		226, 224, 1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 229, 1, 0, 0, 0, 228,
		226, 1, 0, 0, 0, 229, 230, 5, 74, 0, 0, 230, 232, 1, 0, 0, 0, 231, 214,
		1, 0, 0, 0, 232, 233, 1, 0, 0, 0, 233, 231, 1, 0, 0, 0, 233, 234, 1, 0,
		0, 0, 234, 7, 1, 0, 0, 0, 235, 238, 3, 10, 5, 0, 236, 237, 5, 72, 0, 0,
		237, 239, 5, 68, 0, 0, 238, 236, 1, 0, 0, 0, 238, 239, 1, 0, 0, 0, 239,
		242, 1, 0, 0, 0, 240, 241, 5, 5, 0, 0, 241, 243, 5, 68, 0, 0, 242, 240,
		1, 0, 0, 0, 242, 243, 1, 0, 0, 0, 243, 9, 1, 0, 0, 0, 244, 249, 5, 68,
		0, 0, 245, 246, 5, 70, 0, 0, 246, 248, 5, 68, 0, 0, 247, 245, 1, 0, 0,
		0, 248, 251, 1, 0, 0, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250,
		11, 1, 0, 0, 0, 251, 249, 1, 0, 0, 0, 252, 253, 5, 2, 0, 0, 253, 254, 3,
		10, 5, 0, 254, 255, 5, 74, 0, 0, 255, 13, 1, 0, 0, 0, 256, 259, 3, 10,
		5, 0, 257, 259, 5, 68, 0, 0, 258, 256, 1, 0, 0, 0, 258, 257, 1, 0, 0, 0,
		259, 260, 1, 0, 0, 0, 260, 263, 5, 72, 0, 0, 261, 264, 3, 164, 82, 0, 262,
		264, 5, 68, 0, 0, 263, 261, 1, 0, 0, 0, 263, 262, 1, 0, 0, 0, 264, 15,
		1, 0, 0, 0, 265, 267, 5, 20, 0, 0, 266, 265, 1, 0, 0, 0, 266, 267, 1, 0,
		0, 0, 267, 268, 1, 0, 0, 0, 268, 269, 5, 12, 0, 0, 269, 271, 5, 68, 0,
		0, 270, 272, 3, 18, 9, 0, 271, 270, 1, 0, 0, 0, 271, 272, 1, 0, 0, 0, 272,
		274, 1, 0, 0, 0, 273, 275, 3, 20, 10, 0, 274, 273, 1, 0, 0, 0, 274, 275,
		1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 277, 3, 22, 11, 0, 277, 17, 1, 0,
		0, 0, 278, 290, 5, 14, 0, 0, 279, 291, 5, 68, 0, 0, 280, 281, 5, 75, 0,
		0, 281, 286, 5, 68, 0, 0, 282, 283, 5, 69, 0, 0, 283, 285, 5, 68, 0, 0,
		284, 282, 1, 0, 0, 0, 285, 288, 1, 0, 0, 0, 286, 284, 1, 0, 0, 0, 286,
		287, 1, 0, 0, 0, 287, 289, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 289, 291,
		5, 76, 0, 0, 290, 279, 1, 0, 0, 0, 290, 280, 1, 0, 0, 0, 291, 19, 1, 0,
		0, 0, 292, 304, 5, 15, 0, 0, 293, 305, 5, 68, 0, 0, 294, 295, 5, 75, 0,
		0, 295, 300, 5, 68, 0, 0, 296, 297, 5, 69, 0, 0, 297, 299, 5, 68, 0, 0,
		298, 296, 1, 0, 0, 0, 299, 302, 1, 0, 0, 0, 300, 298, 1, 0, 0, 0, 300,
		301, 1, 0, 0, 0, 301, 303, 1, 0, 0, 0, 302, 300, 1, 0, 0, 0, 303, 305,
		5, 76, 0, 0, 304, 293, 1, 0, 0, 0, 304, 294, 1, 0, 0, 0, 305, 21, 1, 0,
		0, 0, 306, 310, 5, 77, 0, 0, 307, 309, 3, 24, 12, 0, 308, 307, 1, 0, 0,
		0, 309, 312, 1, 0, 0, 0, 310, 308, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311,
		316, 1, 0, 0, 0, 312, 310, 1, 0, 0, 0, 313, 315, 3, 34, 17, 0, 314, 313,
		1, 0, 0, 0, 315, 318, 1, 0, 0, 0, 316, 314, 1, 0, 0, 0, 316, 317, 1, 0,
		0, 0, 317, 322, 1, 0, 0, 0, 318, 316, 1, 0, 0, 0, 319, 321, 3, 28, 14,
		0, 320, 319, 1, 0, 0, 0, 321, 324, 1, 0, 0, 0, 322, 320, 1, 0, 0, 0, 322,
		323, 1, 0, 0, 0, 323, 325, 1, 0, 0, 0, 324, 322, 1, 0, 0, 0, 325, 326,
		5, 78, 0, 0, 326, 23, 1, 0, 0, 0, 327, 328, 3, 32, 16, 0, 328, 329, 3,
		174, 87, 0, 329, 25, 1, 0, 0, 0, 330, 331, 7, 0, 0, 0, 331, 27, 1, 0, 0,
		0, 332, 333, 3, 32, 16, 0, 333, 334, 3, 152, 76, 0, 334, 337, 1, 0, 0,
		0, 335, 337, 3, 30, 15, 0, 336, 332, 1, 0, 0, 0, 336, 335, 1, 0, 0, 0,
		337, 29, 1, 0, 0, 0, 338, 339, 5, 20, 0, 0, 339, 340, 5, 11, 0, 0, 340,
		341, 5, 68, 0, 0, 341, 343, 5, 75, 0, 0, 342, 344, 3, 156, 78, 0, 343,
		342, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 347,
		5, 76, 0, 0, 346, 348, 3, 168, 84, 0, 347, 346, 1, 0, 0, 0, 347, 348, 1,
		0, 0, 0, 348, 31, 1, 0, 0, 0, 349, 351, 7, 1, 0, 0, 350, 349, 1, 0, 0,
		0, 350, 351, 1, 0, 0, 0, 351, 353, 1, 0, 0, 0, 352, 354, 5, 36, 0, 0, 353,
		352, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 356, 1, 0, 0, 0, 355, 357,
		3, 26, 13, 0, 356, 355, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 359, 1,
		0, 0, 0, 358, 360, 5, 19, 0, 0, 359, 358, 1, 0, 0, 0, 359, 360, 1, 0, 0,
		0, 360, 362, 1, 0, 0, 0, 361, 363, 5, 21, 0, 0, 362, 361, 1, 0, 0, 0, 362,
		363, 1, 0, 0, 0, 363, 33, 1, 0, 0, 0, 364, 366, 3, 26, 13, 0, 365, 364,
		1, 0, 0, 0, 365, 366, 1, 0, 0, 0, 366, 367, 1, 0, 0, 0, 367, 368, 5, 68,
		0, 0, 368, 370, 5, 75, 0, 0, 369, 371, 3, 156, 78, 0, 370, 369, 1, 0, 0,
		0, 370, 371, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 373, 5, 76, 0, 0, 373,
		374, 3, 170, 85, 0, 374, 35, 1, 0, 0, 0, 375, 394, 5, 8, 0, 0, 376, 395,
		3, 164, 82, 0, 377, 378, 5, 68, 0, 0, 378, 391, 5, 77, 0, 0, 379, 380,
		5, 68, 0, 0, 380, 381, 5, 81, 0, 0, 381, 388, 3, 66, 33, 0, 382, 383, 5,
		69, 0, 0, 383, 384, 5, 68, 0, 0, 384, 385, 5, 81, 0, 0, 385, 387, 3, 66,
		33, 0, 386, 382, 1, 0, 0, 0, 387, 390, 1, 0, 0, 0, 388, 386, 1, 0, 0, 0,
		388, 389, 1, 0, 0, 0, 389, 392, 1, 0, 0, 0, 390, 388, 1, 0, 0, 0, 391,
		379, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392, 393, 1, 0, 0, 0, 393, 395,
		5, 78, 0, 0, 394, 376, 1, 0, 0, 0, 394, 377, 1, 0, 0, 0, 395, 37, 1, 0,
		0, 0, 396, 399, 5, 7, 0, 0, 397, 399, 3, 178, 89, 0, 398, 396, 1, 0, 0,
		0, 398, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 401, 5, 70, 0, 0, 401,
		402, 3, 164, 82, 0, 402, 39, 1, 0, 0, 0, 403, 406, 5, 68, 0, 0, 404, 406,
		3, 164, 82, 0, 405, 403, 1, 0, 0, 0, 405, 404, 1, 0, 0, 0, 406, 412, 1,
		0, 0, 0, 407, 408, 5, 70, 0, 0, 408, 411, 5, 68, 0, 0, 409, 411, 3, 164,
		82, 0, 410, 407, 1, 0, 0, 0, 410, 409, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0,
		412, 410, 1, 0, 0, 0, 412, 413, 1, 0, 0, 0, 413, 41, 1, 0, 0, 0, 414, 412,
		1, 0, 0, 0, 415, 416, 5, 13, 0, 0, 416, 418, 5, 68, 0, 0, 417, 419, 3,
		44, 22, 0, 418, 417, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 420, 1, 0,
		0, 0, 420, 421, 3, 46, 23, 0, 421, 43, 1, 0, 0, 0, 422, 434, 5, 14, 0,
		0, 423, 435, 5, 68, 0, 0, 424, 425, 5, 75, 0, 0, 425, 430, 5, 68, 0, 0,
		426, 427, 5, 69, 0, 0, 427, 429, 5, 68, 0, 0, 428, 426, 1, 0, 0, 0, 429,
		432, 1, 0, 0, 0, 430, 428, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 433,
		1, 0, 0, 0, 432, 430, 1, 0, 0, 0, 433, 435, 5, 76, 0, 0, 434, 423, 1, 0,
		0, 0, 434, 424, 1, 0, 0, 0, 435, 45, 1, 0, 0, 0, 436, 440, 5, 77, 0, 0,
		437, 439, 3, 48, 24, 0, 438, 437, 1, 0, 0, 0, 439, 442, 1, 0, 0, 0, 440,
		438, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 443, 1, 0, 0, 0, 442, 440,
		1, 0, 0, 0, 443, 444, 5, 78, 0, 0, 444, 47, 1, 0, 0, 0, 445, 448, 3, 50,
		25, 0, 446, 448, 3, 52, 26, 0, 447, 445, 1, 0, 0, 0, 447, 446, 1, 0, 0,
		0, 448, 49, 1, 0, 0, 0, 449, 450, 5, 11, 0, 0, 450, 451, 5, 68, 0, 0, 451,
		453, 5, 75, 0, 0, 452, 454, 3, 156, 78, 0, 453, 452, 1, 0, 0, 0, 453, 454,
		1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 457, 5, 76, 0, 0, 456, 458, 3, 168,
		84, 0, 457, 456, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 51, 1, 0, 0, 0,
		459, 460, 5, 68, 0, 0, 460, 461, 5, 71, 0, 0, 461, 462, 3, 182, 91, 0,
		462, 53, 1, 0, 0, 0, 463, 464, 5, 10, 0, 0, 464, 465, 5, 68, 0, 0, 465,
		466, 3, 56, 28, 0, 466, 55, 1, 0, 0, 0, 467, 471, 5, 77, 0, 0, 468, 470,
		3, 58, 29, 0, 469, 468, 1, 0, 0, 0, 470, 473, 1, 0, 0, 0, 471, 469, 1,
		0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 474, 1, 0, 0, 0, 473, 471, 1, 0, 0,
		0, 474, 475, 5, 78, 0, 0, 475, 57, 1, 0, 0, 0, 476, 477, 3, 174, 87, 0,
		477, 59, 1, 0, 0, 0, 478, 479, 5, 9, 0, 0, 479, 480, 5, 68, 0, 0, 480,
		481, 3, 62, 31, 0, 481, 61, 1, 0, 0, 0, 482, 486, 5, 77, 0, 0, 483, 485,
		3, 64, 32, 0, 484, 483, 1, 0, 0, 0, 485, 488, 1, 0, 0, 0, 486, 484, 1,
		0, 0, 0, 486, 487, 1, 0, 0, 0, 487, 489, 1, 0, 0, 0, 488, 486, 1, 0, 0,
		0, 489, 490, 5, 78, 0, 0, 490, 63, 1, 0, 0, 0, 491, 494, 5, 68, 0, 0, 492,
		493, 5, 81, 0, 0, 493, 495, 5, 121, 0, 0, 494, 492, 1, 0, 0, 0, 494, 495,
		1, 0, 0, 0, 495, 65, 1, 0, 0, 0, 496, 497, 6, 33, -1, 0, 497, 518, 3, 36,
		18, 0, 498, 518, 3, 164, 82, 0, 499, 518, 3, 154, 77, 0, 500, 518, 3, 116,
		58, 0, 501, 518, 3, 38, 19, 0, 502, 518, 3, 14, 7, 0, 503, 518, 3, 40,
		20, 0, 504, 518, 3, 86, 43, 0, 505, 518, 3, 68, 34, 0, 506, 518, 3, 78,
		39, 0, 507, 510, 3, 182, 91, 0, 508, 510, 5, 68, 0, 0, 509, 507, 1, 0,
		0, 0, 509, 508, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 5, 75, 0, 0,
		512, 513, 3, 66, 33, 0, 513, 514, 5, 76, 0, 0, 514, 518, 1, 0, 0, 0, 515,
		518, 5, 68, 0, 0, 516, 518, 5, 62, 0, 0, 517, 496, 1, 0, 0, 0, 517, 498,
		1, 0, 0, 0, 517, 499, 1, 0, 0, 0, 517, 500, 1, 0, 0, 0, 517, 501, 1, 0,
		0, 0, 517, 502, 1, 0, 0, 0, 517, 503, 1, 0, 0, 0, 517, 504, 1, 0, 0, 0,
		517, 505, 1, 0, 0, 0, 517, 506, 1, 0, 0, 0, 517, 509, 1, 0, 0, 0, 517,
		515, 1, 0, 0, 0, 517, 516, 1, 0, 0, 0, 518, 537, 1, 0, 0, 0, 519, 520,
		10, 6, 0, 0, 520, 521, 3, 114, 57, 0, 521, 522, 3, 66, 33, 7, 522, 536,
		1, 0, 0, 0, 523, 524, 10, 5, 0, 0, 524, 525, 5, 118, 0, 0, 525, 526, 3,
		66, 33, 0, 526, 527, 5, 71, 0, 0, 527, 528, 3, 66, 33, 6, 528, 536, 1,
		0, 0, 0, 529, 530, 10, 4, 0, 0, 530, 531, 5, 119, 0, 0, 531, 536, 3, 66,
		33, 5, 532, 533, 10, 7, 0, 0, 533, 534, 5, 38, 0, 0, 534, 536, 3, 182,
		91, 0, 535, 519, 1, 0, 0, 0, 535, 523, 1, 0, 0, 0, 535, 529, 1, 0, 0, 0,
		535, 532, 1, 0, 0, 0, 536, 539, 1, 0, 0, 0, 537, 535, 1, 0, 0, 0, 537,
		538, 1, 0, 0, 0, 538, 67, 1, 0, 0, 0, 539, 537, 1, 0, 0, 0, 540, 545, 3,
		70, 35, 0, 541, 545, 3, 72, 36, 0, 542, 545, 3, 74, 37, 0, 543, 545, 3,
		76, 38, 0, 544, 540, 1, 0, 0, 0, 544, 541, 1, 0, 0, 0, 544, 542, 1, 0,
		0, 0, 544, 543, 1, 0, 0, 0, 545, 69, 1, 0, 0, 0, 546, 555, 5, 77, 0, 0,
		547, 552, 3, 66, 33, 0, 548, 549, 5, 69, 0, 0, 549, 551, 3, 66, 33, 0,
		550, 548, 1, 0, 0, 0, 551, 554, 1, 0, 0, 0, 552, 550, 1, 0, 0, 0, 552,
		553, 1, 0, 0, 0, 553, 556, 1, 0, 0, 0, 554, 552, 1, 0, 0, 0, 555, 547,
		1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 558, 5, 78,
		0, 0, 558, 71, 1, 0, 0, 0, 559, 573, 5, 77, 0, 0, 560, 561, 3, 66, 33,
		0, 561, 562, 5, 71, 0, 0, 562, 570, 3, 66, 33, 0, 563, 564, 5, 69, 0, 0,
		564, 565, 3, 66, 33, 0, 565, 566, 5, 71, 0, 0, 566, 567, 3, 66, 33, 0,
		567, 569, 1, 0, 0, 0, 568, 563, 1, 0, 0, 0, 569, 572, 1, 0, 0, 0, 570,
		568, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 574, 1, 0, 0, 0, 572, 570,
		1, 0, 0, 0, 573, 560, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 575, 1, 0,
		0, 0, 575, 576, 5, 78, 0, 0, 576, 73, 1, 0, 0, 0, 577, 586, 5, 75, 0, 0,
		578, 583, 3, 66, 33, 0, 579, 580, 5, 69, 0, 0, 580, 582, 3, 66, 33, 0,
		581, 579, 1, 0, 0, 0, 582, 585, 1, 0, 0, 0, 583, 581, 1, 0, 0, 0, 583,
		584, 1, 0, 0, 0, 584, 587, 1, 0, 0, 0, 585, 583, 1, 0, 0, 0, 586, 578,
		1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 589, 5, 76,
		0, 0, 589, 75, 1, 0, 0, 0, 590, 603, 5, 75, 0, 0, 591, 592, 5, 68, 0, 0,
		592, 593, 5, 71, 0, 0, 593, 600, 3, 66, 33, 0, 594, 595, 5, 69, 0, 0, 595,
		596, 5, 68, 0, 0, 596, 597, 5, 71, 0, 0, 597, 599, 3, 66, 33, 0, 598, 594,
		1, 0, 0, 0, 599, 602, 1, 0, 0, 0, 600, 598, 1, 0, 0, 0, 600, 601, 1, 0,
		0, 0, 601, 604, 1, 0, 0, 0, 602, 600, 1, 0, 0, 0, 603, 591, 1, 0, 0, 0,
		603, 604, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605, 606, 5, 76, 0, 0, 606,
		77, 1, 0, 0, 0, 607, 608, 6, 39, -1, 0, 608, 609, 3, 80, 40, 0, 609, 615,
		1, 0, 0, 0, 610, 611, 10, 2, 0, 0, 611, 612, 5, 100, 0, 0, 612, 614, 3,
		80, 40, 0, 613, 610, 1, 0, 0, 0, 614, 617, 1, 0, 0, 0, 615, 613, 1, 0,
		0, 0, 615, 616, 1, 0, 0, 0, 616, 79, 1, 0, 0, 0, 617, 615, 1, 0, 0, 0,
		618, 619, 6, 40, -1, 0, 619, 620, 3, 82, 41, 0, 620, 626, 1, 0, 0, 0, 621,
		622, 10, 2, 0, 0, 622, 623, 5, 101, 0, 0, 623, 625, 3, 82, 41, 0, 624,
		621, 1, 0, 0, 0, 625, 628, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 626, 627,
		1, 0, 0, 0, 627, 81, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 629, 630, 6, 41,
		-1, 0, 630, 631, 3, 84, 42, 0, 631, 637, 1, 0, 0, 0, 632, 633, 10, 2, 0,
		0, 633, 634, 5, 102, 0, 0, 634, 636, 3, 84, 42, 0, 635, 632, 1, 0, 0, 0,
		636, 639, 1, 0, 0, 0, 637, 635, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638,
		83, 1, 0, 0, 0, 639, 637, 1, 0, 0, 0, 640, 641, 5, 103, 0, 0, 641, 644,
		3, 84, 42, 0, 642, 644, 5, 6, 0, 0, 643, 640, 1, 0, 0, 0, 643, 642, 1,
		0, 0, 0, 644, 85, 1, 0, 0, 0, 645, 646, 6, 43, -1, 0, 646, 647, 3, 88,
		44, 0, 647, 654, 1, 0, 0, 0, 648, 649, 10, 2, 0, 0, 649, 650, 3, 112, 56,
		0, 650, 651, 3, 88, 44, 0, 651, 653, 1, 0, 0, 0, 652, 648, 1, 0, 0, 0,
		653, 656, 1, 0, 0, 0, 654, 652, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655,
		87, 1, 0, 0, 0, 656, 654, 1, 0, 0, 0, 657, 658, 6, 44, -1, 0, 658, 659,
		3, 90, 45, 0, 659, 666, 1, 0, 0, 0, 660, 661, 10, 2, 0, 0, 661, 662, 3,
		110, 55, 0, 662, 663, 3, 90, 45, 0, 663, 665, 1, 0, 0, 0, 664, 660, 1,
		0, 0, 0, 665, 668, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 666, 667, 1, 0, 0,
		0, 667, 89, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 669, 670, 6, 45, -1, 0, 670,
		671, 3, 92, 46, 0, 671, 677, 1, 0, 0, 0, 672, 673, 10, 2, 0, 0, 673, 674,
		5, 113, 0, 0, 674, 676, 3, 92, 46, 0, 675, 672, 1, 0, 0, 0, 676, 679, 1,
		0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 91, 1, 0, 0,
		0, 679, 677, 1, 0, 0, 0, 680, 681, 6, 46, -1, 0, 681, 682, 3, 94, 47, 0,
		682, 689, 1, 0, 0, 0, 683, 684, 10, 2, 0, 0, 684, 685, 3, 106, 53, 0, 685,
		686, 3, 94, 47, 0, 686, 688, 1, 0, 0, 0, 687, 683, 1, 0, 0, 0, 688, 691,
		1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 93, 1, 0,
		0, 0, 691, 689, 1, 0, 0, 0, 692, 693, 6, 47, -1, 0, 693, 694, 3, 96, 48,
		0, 694, 701, 1, 0, 0, 0, 695, 696, 10, 2, 0, 0, 696, 697, 3, 108, 54, 0,
		697, 698, 3, 96, 48, 0, 698, 700, 1, 0, 0, 0, 699, 695, 1, 0, 0, 0, 700,
		703, 1, 0, 0, 0, 701, 699, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 95, 1,
		0, 0, 0, 703, 701, 1, 0, 0, 0, 704, 709, 3, 98, 49, 0, 705, 709, 3, 100,
		50, 0, 706, 709, 3, 102, 51, 0, 707, 709, 3, 104, 52, 0, 708, 704, 1, 0,
		0, 0, 708, 705, 1, 0, 0, 0, 708, 706, 1, 0, 0, 0, 708, 707, 1, 0, 0, 0,
		709, 97, 1, 0, 0, 0, 710, 711, 5, 116, 0, 0, 711, 717, 3, 102, 51, 0, 712,
		713, 5, 117, 0, 0, 713, 717, 3, 102, 51, 0, 714, 715, 5, 107, 0, 0, 715,
		717, 3, 102, 51, 0, 716, 710, 1, 0, 0, 0, 716, 712, 1, 0, 0, 0, 716, 714,
		1, 0, 0, 0, 717, 99, 1, 0, 0, 0, 718, 719, 3, 102, 51, 0, 719, 720, 5,
		116, 0, 0, 720, 725, 1, 0, 0, 0, 721, 722, 3, 102, 51, 0, 722, 723, 5,
		117, 0, 0, 723, 725, 1, 0, 0, 0, 724, 718, 1, 0, 0, 0, 724, 721, 1, 0,
		0, 0, 725, 101, 1, 0, 0, 0, 726, 729, 3, 178, 89, 0, 727, 729, 5, 121,
		0, 0, 728, 726, 1, 0, 0, 0, 728, 727, 1, 0, 0, 0, 729, 103, 1, 0, 0, 0,
		730, 731, 5, 75, 0, 0, 731, 732, 3, 86, 43, 0, 732, 733, 5, 76, 0, 0, 733,
		105, 1, 0, 0, 0, 734, 735, 7, 2, 0, 0, 735, 107, 1, 0, 0, 0, 736, 737,
		7, 3, 0, 0, 737, 109, 1, 0, 0, 0, 738, 739, 7, 4, 0, 0, 739, 111, 1, 0,
		0, 0, 740, 741, 7, 5, 0, 0, 741, 113, 1, 0, 0, 0, 742, 743, 7, 6, 0, 0,
		743, 115, 1, 0, 0, 0, 744, 745, 7, 7, 0, 0, 745, 117, 1, 0, 0, 0, 746,
		759, 3, 174, 87, 0, 747, 759, 3, 176, 88, 0, 748, 759, 3, 66, 33, 0, 749,
		759, 3, 122, 61, 0, 750, 759, 3, 144, 72, 0, 751, 759, 3, 130, 65, 0, 752,
		759, 3, 132, 66, 0, 753, 759, 3, 134, 67, 0, 754, 759, 3, 138, 69, 0, 755,
		759, 3, 120, 60, 0, 756, 759, 5, 32, 0, 0, 757, 759, 5, 33, 0, 0, 758,
		746, 1, 0, 0, 0, 758, 747, 1, 0, 0, 0, 758, 748, 1, 0, 0, 0, 758, 749,
		1, 0, 0, 0, 758, 750, 1, 0, 0, 0, 758, 751, 1, 0, 0, 0, 758, 752, 1, 0,
		0, 0, 758, 753, 1, 0, 0, 0, 758, 754, 1, 0, 0, 0, 758, 755, 1, 0, 0, 0,
		758, 756, 1, 0, 0, 0, 758, 757, 1, 0, 0, 0, 759, 119, 1, 0, 0, 0, 760,
		764, 5, 77, 0, 0, 761, 763, 3, 118, 59, 0, 762, 761, 1, 0, 0, 0, 763, 766,
		1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 767, 1, 0,
		0, 0, 766, 764, 1, 0, 0, 0, 767, 768, 5, 78, 0, 0, 768, 121, 1, 0, 0, 0,
		769, 770, 5, 31, 0, 0, 770, 771, 5, 75, 0, 0, 771, 772, 3, 124, 62, 0,
		772, 773, 5, 76, 0, 0, 773, 777, 5, 77, 0, 0, 774, 776, 3, 118, 59, 0,
		775, 774, 1, 0, 0, 0, 776, 779, 1, 0, 0, 0, 777, 775, 1, 0, 0, 0, 777,
		778, 1, 0, 0, 0, 778, 780, 1, 0, 0, 0, 779, 777, 1, 0, 0, 0, 780, 781,
		5, 78, 0, 0, 781, 123, 1, 0, 0, 0, 782, 785, 3, 126, 63, 0, 783, 785, 3,
		128, 64, 0, 784, 782, 1, 0, 0, 0, 784, 783, 1, 0, 0, 0, 785, 125, 1, 0,
		0, 0, 786, 787, 7, 8, 0, 0, 787, 788, 5, 69, 0, 0, 788, 789, 7, 8, 0, 0,
		789, 790, 5, 37, 0, 0, 790, 791, 3, 66, 33, 0, 791, 127, 1, 0, 0, 0, 792,
		793, 3, 174, 87, 0, 793, 795, 5, 74, 0, 0, 794, 796, 3, 66, 33, 0, 795,
		794, 1, 0, 0, 0, 795, 796, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 799,
		5, 74, 0, 0, 798, 800, 3, 66, 33, 0, 799, 798, 1, 0, 0, 0, 799, 800, 1,
		0, 0, 0, 800, 129, 1, 0, 0, 0, 801, 802, 5, 29, 0, 0, 802, 803, 5, 75,
		0, 0, 803, 804, 3, 66, 33, 0, 804, 805, 5, 76, 0, 0, 805, 809, 5, 77, 0,
		0, 806, 808, 3, 118, 59, 0, 807, 806, 1, 0, 0, 0, 808, 811, 1, 0, 0, 0,
		809, 807, 1, 0, 0, 0, 809, 810, 1, 0, 0, 0, 810, 812, 1, 0, 0, 0, 811,
		809, 1, 0, 0, 0, 812, 813, 5, 78, 0, 0, 813, 131, 1, 0, 0, 0, 814, 815,
		5, 30, 0, 0, 815, 819, 5, 77, 0, 0, 816, 818, 3, 118, 59, 0, 817, 816,
		1, 0, 0, 0, 818, 821, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 819, 820, 1, 0,
		0, 0, 820, 822, 1, 0, 0, 0, 821, 819, 1, 0, 0, 0, 822, 823, 5, 78, 0, 0,
		823, 824, 5, 29, 0, 0, 824, 825, 5, 75, 0, 0, 825, 826, 3, 66, 33, 0, 826,
		827, 5, 76, 0, 0, 827, 133, 1, 0, 0, 0, 828, 829, 5, 26, 0, 0, 829, 830,
		5, 75, 0, 0, 830, 831, 3, 66, 33, 0, 831, 832, 5, 76, 0, 0, 832, 836, 5,
		77, 0, 0, 833, 835, 3, 136, 68, 0, 834, 833, 1, 0, 0, 0, 835, 838, 1, 0,
		0, 0, 836, 834, 1, 0, 0, 0, 836, 837, 1, 0, 0, 0, 837, 839, 1, 0, 0, 0,
		838, 836, 1, 0, 0, 0, 839, 840, 5, 78, 0, 0, 840, 135, 1, 0, 0, 0, 841,
		842, 5, 27, 0, 0, 842, 843, 3, 66, 33, 0, 843, 847, 5, 71, 0, 0, 844, 846,
		3, 118, 59, 0, 845, 844, 1, 0, 0, 0, 846, 849, 1, 0, 0, 0, 847, 845, 1,
		0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 859, 1, 0, 0, 0, 849, 847, 1, 0, 0,
		0, 850, 851, 5, 28, 0, 0, 851, 855, 5, 71, 0, 0, 852, 854, 3, 118, 59,
		0, 853, 852, 1, 0, 0, 0, 854, 857, 1, 0, 0, 0, 855, 853, 1, 0, 0, 0, 855,
		856, 1, 0, 0, 0, 856, 859, 1, 0, 0, 0, 857, 855, 1, 0, 0, 0, 858, 841,
		1, 0, 0, 0, 858, 850, 1, 0, 0, 0, 859, 137, 1, 0, 0, 0, 860, 861, 5, 39,
		0, 0, 861, 865, 5, 77, 0, 0, 862, 864, 3, 118, 59, 0, 863, 862, 1, 0, 0,
		0, 864, 867, 1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 865, 866, 1, 0, 0, 0, 866,
		868, 1, 0, 0, 0, 867, 865, 1, 0, 0, 0, 868, 870, 5, 78, 0, 0, 869, 871,
		3, 140, 70, 0, 870, 869, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871, 873, 1,
		0, 0, 0, 872, 874, 3, 142, 71, 0, 873, 872, 1, 0, 0, 0, 873, 874, 1, 0,
		0, 0, 874, 139, 1, 0, 0, 0, 875, 876, 5, 40, 0, 0, 876, 877, 5, 75, 0,
		0, 877, 878, 5, 68, 0, 0, 878, 879, 5, 71, 0, 0, 879, 880, 5, 68, 0, 0,
		880, 881, 5, 76, 0, 0, 881, 885, 5, 77, 0, 0, 882, 884, 3, 118, 59, 0,
		883, 882, 1, 0, 0, 0, 884, 887, 1, 0, 0, 0, 885, 883, 1, 0, 0, 0, 885,
		886, 1, 0, 0, 0, 886, 888, 1, 0, 0, 0, 887, 885, 1, 0, 0, 0, 888, 889,
		5, 78, 0, 0, 889, 141, 1, 0, 0, 0, 890, 891, 5, 41, 0, 0, 891, 895, 5,
		77, 0, 0, 892, 894, 3, 118, 59, 0, 893, 892, 1, 0, 0, 0, 894, 897, 1, 0,
		0, 0, 895, 893, 1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898, 1, 0, 0, 0,
		897, 895, 1, 0, 0, 0, 898, 899, 5, 78, 0, 0, 899, 143, 1, 0, 0, 0, 900,
		901, 5, 23, 0, 0, 901, 902, 5, 75, 0, 0, 902, 903, 3, 66, 33, 0, 903, 904,
		5, 76, 0, 0, 904, 908, 5, 77, 0, 0, 905, 907, 3, 118, 59, 0, 906, 905,
		1, 0, 0, 0, 907, 910, 1, 0, 0, 0, 908, 906, 1, 0, 0, 0, 908, 909, 1, 0,
		0, 0, 909, 911, 1, 0, 0, 0, 910, 908, 1, 0, 0, 0, 911, 915, 5, 78, 0, 0,
		912, 914, 3, 146, 73, 0, 913, 912, 1, 0, 0, 0, 914, 917, 1, 0, 0, 0, 915,
		913, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 919, 1, 0, 0, 0, 917, 915,
		1, 0, 0, 0, 918, 920, 3, 148, 74, 0, 919, 918, 1, 0, 0, 0, 919, 920, 1,
		0, 0, 0, 920, 145, 1, 0, 0, 0, 921, 922, 5, 25, 0, 0, 922, 923, 5, 75,
		0, 0, 923, 924, 3, 66, 33, 0, 924, 925, 5, 76, 0, 0, 925, 929, 5, 77, 0,
		0, 926, 928, 3, 118, 59, 0, 927, 926, 1, 0, 0, 0, 928, 931, 1, 0, 0, 0,
		929, 927, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 932, 1, 0, 0, 0, 931,
		929, 1, 0, 0, 0, 932, 933, 5, 78, 0, 0, 933, 147, 1, 0, 0, 0, 934, 935,
		5, 24, 0, 0, 935, 939, 5, 77, 0, 0, 936, 938, 3, 118, 59, 0, 937, 936,
		1, 0, 0, 0, 938, 941, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 939, 940, 1, 0,
		0, 0, 940, 942, 1, 0, 0, 0, 941, 939, 1, 0, 0, 0, 942, 943, 5, 78, 0, 0,
		943, 149, 1, 0, 0, 0, 944, 945, 5, 75, 0, 0, 945, 947, 5, 68, 0, 0, 946,
		948, 5, 112, 0, 0, 947, 946, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948, 949,
		1, 0, 0, 0, 949, 950, 5, 68, 0, 0, 950, 951, 5, 76, 0, 0, 951, 952, 3,
		152, 76, 0, 952, 151, 1, 0, 0, 0, 953, 954, 5, 11, 0, 0, 954, 955, 5, 68,
		0, 0, 955, 957, 5, 75, 0, 0, 956, 958, 3, 156, 78, 0, 957, 956, 1, 0, 0,
		0, 957, 958, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 961, 5, 76, 0, 0, 960,
		962, 3, 168, 84, 0, 961, 960, 1, 0, 0, 0, 961, 962, 1, 0, 0, 0, 962, 963,
		1, 0, 0, 0, 963, 964, 3, 170, 85, 0, 964, 153, 1, 0, 0, 0, 965, 966, 5,
		11, 0, 0, 966, 968, 5, 75, 0, 0, 967, 969, 3, 156, 78, 0, 968, 967, 1,
		0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 970, 1, 0, 0, 0, 970, 972, 5, 76, 0,
		0, 971, 973, 3, 168, 84, 0, 972, 971, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0,
		973, 974, 1, 0, 0, 0, 974, 975, 5, 73, 0, 0, 975, 976, 3, 170, 85, 0, 976,
		155, 1, 0, 0, 0, 977, 982, 3, 162, 81, 0, 978, 979, 5, 69, 0, 0, 979, 981,
		3, 162, 81, 0, 980, 978, 1, 0, 0, 0, 981, 984, 1, 0, 0, 0, 982, 980, 1,
		0, 0, 0, 982, 983, 1, 0, 0, 0, 983, 157, 1, 0, 0, 0, 984, 982, 1, 0, 0,
		0, 985, 986, 5, 11, 0, 0, 986, 988, 5, 75, 0, 0, 987, 989, 3, 160, 80,
		0, 988, 987, 1, 0, 0, 0, 988, 989, 1, 0, 0, 0, 989, 990, 1, 0, 0, 0, 990,
		992, 5, 76, 0, 0, 991, 993, 3, 168, 84, 0, 992, 991, 1, 0, 0, 0, 992, 993,
		1, 0, 0, 0, 993, 159, 1, 0, 0, 0, 994, 999, 3, 182, 91, 0, 995, 996, 5,
		69, 0, 0, 996, 998, 3, 182, 91, 0, 997, 995, 1, 0, 0, 0, 998, 1001, 1,
		0, 0, 0, 999, 997, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 161, 1, 0,
		0, 0, 1001, 999, 1, 0, 0, 0, 1002, 1004, 5, 68, 0, 0, 1003, 1005, 5, 118,
		0, 0, 1004, 1003, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 1006, 1, 0,
		0, 0, 1006, 1007, 5, 71, 0, 0, 1007, 1009, 3, 182, 91, 0, 1008, 1010, 5,
		120, 0, 0, 1009, 1008, 1, 0, 0, 0, 1009, 1010, 1, 0, 0, 0, 1010, 1013,
		1, 0, 0, 0, 1011, 1012, 5, 81, 0, 0, 1012, 1014, 3, 116, 58, 0, 1013, 1011,
		1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 163, 1, 0, 0, 0, 1015, 1016,
		5, 68, 0, 0, 1016, 1018, 5, 75, 0, 0, 1017, 1019, 3, 166, 83, 0, 1018,
		1017, 1, 0, 0, 0, 1018, 1019, 1, 0, 0, 0, 1019, 1020, 1, 0, 0, 0, 1020,
		1021, 5, 76, 0, 0, 1021, 165, 1, 0, 0, 0, 1022, 1027, 3, 66, 33, 0, 1023,
		1024, 5, 69, 0, 0, 1024, 1026, 3, 66, 33, 0, 1025, 1023, 1, 0, 0, 0, 1026,
		1029, 1, 0, 0, 0, 1027, 1025, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028,
		167, 1, 0, 0, 0, 1029, 1027, 1, 0, 0, 0, 1030, 1043, 3, 182, 91, 0, 1031,
		1032, 5, 75, 0, 0, 1032, 1037, 3, 182, 91, 0, 1033, 1034, 5, 69, 0, 0,
		1034, 1036, 3, 182, 91, 0, 1035, 1033, 1, 0, 0, 0, 1036, 1039, 1, 0, 0,
		0, 1037, 1035, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 1040, 1, 0, 0,
		0, 1039, 1037, 1, 0, 0, 0, 1040, 1041, 5, 76, 0, 0, 1041, 1043, 1, 0, 0,
		0, 1042, 1030, 1, 0, 0, 0, 1042, 1031, 1, 0, 0, 0, 1043, 169, 1, 0, 0,
		0, 1044, 1048, 5, 77, 0, 0, 1045, 1047, 3, 118, 59, 0, 1046, 1045, 1, 0,
		0, 0, 1047, 1050, 1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1048, 1049, 1, 0,
		0, 0, 1049, 1052, 1, 0, 0, 0, 1050, 1048, 1, 0, 0, 0, 1051, 1053, 3, 172,
		86, 0, 1052, 1051, 1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1054, 1, 0,
		0, 0, 1054, 1055, 5, 78, 0, 0, 1055, 171, 1, 0, 0, 0, 1056, 1057, 5, 34,
		0, 0, 1057, 1062, 3, 66, 33, 0, 1058, 1059, 5, 69, 0, 0, 1059, 1061, 3,
		66, 33, 0, 1060, 1058, 1, 0, 0, 0, 1061, 1064, 1, 0, 0, 0, 1062, 1060,
		1, 0, 0, 0, 1062, 1063, 1, 0, 0, 0, 1063, 173, 1, 0, 0, 0, 1064, 1062,
		1, 0, 0, 0, 1065, 1066, 5, 68, 0, 0, 1066, 1067, 5, 71, 0, 0, 1067, 1068,
		3, 182, 91, 0, 1068, 1071, 1, 0, 0, 0, 1069, 1070, 5, 81, 0, 0, 1070, 1072,
		3, 66, 33, 0, 1071, 1069, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 175,
		1, 0, 0, 0, 1073, 1074, 3, 178, 89, 0, 1074, 1075, 3, 180, 90, 0, 1075,
		1076, 3, 66, 33, 0, 1076, 177, 1, 0, 0, 0, 1077, 1083, 5, 68, 0, 0, 1078,
		1079, 5, 7, 0, 0, 1079, 1080, 5, 70, 0, 0, 1080, 1083, 5, 68, 0, 0, 1081,
		1083, 5, 67, 0, 0, 1082, 1077, 1, 0, 0, 0, 1082, 1078, 1, 0, 0, 0, 1082,
		1081, 1, 0, 0, 0, 1083, 179, 1, 0, 0, 0, 1084, 1085, 7, 9, 0, 0, 1085,
		181, 1, 0, 0, 0, 1086, 1088, 5, 35, 0, 0, 1087, 1086, 1, 0, 0, 0, 1087,
		1088, 1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 1107, 3, 184, 92, 0, 1090,
		1106, 5, 118, 0, 0, 1091, 1093, 5, 79, 0, 0, 1092, 1094, 7, 10, 0, 0, 1093,
		1092, 1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095,
		1106, 5, 80, 0, 0, 1096, 1097, 5, 79, 0, 0, 1097, 1098, 3, 184, 92, 0,
		1098, 1100, 5, 75, 0, 0, 1099, 1101, 7, 10, 0, 0, 1100, 1099, 1, 0, 0,
		0, 1100, 1101, 1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 1103, 5, 76, 0,
		0, 1103, 1104, 5, 80, 0, 0, 1104, 1106, 1, 0, 0, 0, 1105, 1090, 1, 0, 0,
		0, 1105, 1091, 1, 0, 0, 0, 1105, 1096, 1, 0, 0, 0, 1106, 1109, 1, 0, 0,
		0, 1107, 1105, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1112, 1, 0, 0,
		0, 1109, 1107, 1, 0, 0, 0, 1110, 1112, 3, 158, 79, 0, 1111, 1087, 1, 0,
		0, 0, 1111, 1110, 1, 0, 0, 0, 1112, 183, 1, 0, 0, 0, 1113, 1114, 7, 11,
		0, 0, 1114, 185, 1, 0, 0, 0, 126, 189, 196, 200, 208, 214, 219, 222, 226,
		233, 238, 242, 249, 258, 263, 266, 271, 274, 286, 290, 300, 304, 310, 316,
		322, 336, 343, 347, 350, 353, 356, 359, 362, 365, 370, 388, 391, 394, 398,
		405, 410, 412, 418, 430, 434, 440, 447, 453, 457, 471, 486, 494, 509, 517,
		535, 537, 544, 552, 555, 570, 573, 583, 586, 600, 603, 615, 626, 637, 643,
		654, 666, 677, 689, 701, 708, 716, 724, 728, 758, 764, 777, 784, 795, 799,
		809, 819, 836, 847, 855, 858, 865, 870, 873, 885, 895, 908, 915, 919, 929,
		939, 947, 957, 961, 968, 972, 982, 988, 992, 999, 1004, 1009, 1013, 1018,
		1027, 1037, 1042, 1048, 1052, 1062, 1071, 1082, 1087, 1093, 1100, 1105,
		1107, 1111,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// FlexarParserInit initializes any static state used to implement FlexarParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewFlexarParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func FlexarParserInit() {
	staticData := &FlexarParserStaticData
	staticData.once.Do(flexarParserInit)
}

// NewFlexarParser produces a new parser instance for the optional input antlr.TokenStream.
func NewFlexarParser(input antlr.TokenStream) *FlexarParser {
	FlexarParserInit()
	this := new(FlexarParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &FlexarParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Flexar.g4"

	return this
}

// FlexarParser tokens.
const (
	FlexarParserEOF             = antlr.TokenEOF
	FlexarParserIMPORT          = 1
	FlexarParserNAMESPACE       = 2
	FlexarParserEXPORT          = 3
	FlexarParserUSE             = 4
	FlexarParserAS              = 5
	FlexarParserBOOLEAN         = 6
	FlexarParserTHIS            = 7
	FlexarParserNEW             = 8
	FlexarParserENUM            = 9
	FlexarParserSTRUCT          = 10
	FlexarParserFUNC            = 11
	FlexarParserCLASS           = 12
	FlexarParserINTERFACE       = 13
	FlexarParserEXTENDS         = 14
	FlexarParserIMPLEMENTS      = 15
	FlexarParserPUBLIC          = 16
	FlexarParserPRIVATE         = 17
	FlexarParserPROTECTED       = 18
	FlexarParserSTATIC          = 19
	FlexarParserABSTRACT        = 20
	FlexarParserFINAL           = 21
	FlexarParserOVERRIDE        = 22
	FlexarParserIF              = 23
	FlexarParserELSE            = 24
	FlexarParserELIF            = 25
	FlexarParserSWITCH          = 26
	FlexarParserCASE            = 27
	FlexarParserDEFAULT         = 28
	FlexarParserWHILE           = 29
	FlexarParserDO              = 30
	FlexarParserFOR             = 31
	FlexarParserBREAK           = 32
	FlexarParserCONTINUE        = 33
	FlexarParserRETURN          = 34
	FlexarParserCONST           = 35
	FlexarParserREADONLY        = 36
	FlexarParserIN              = 37
	FlexarParserIS              = 38
	FlexarParserTRY             = 39
	FlexarParserCATCH           = 40
	FlexarParserFINALLY         = 41
	FlexarParserINT             = 42
	FlexarParserINT8            = 43
	FlexarParserINT16           = 44
	FlexarParserINT32           = 45
	FlexarParserINT64           = 46
	FlexarParserUINT            = 47
	FlexarParserUINT8           = 48
	FlexarParserUINT16          = 49
	FlexarParserUINT32          = 50
	FlexarParserUINT64          = 51
	FlexarParserFLOAT           = 52
	FlexarParserFLOAT32         = 53
	FlexarParserFLOAT64         = 54
	FlexarParserBOOL            = 55
	FlexarParserCHAR            = 56
	FlexarParserSTRING          = 57
	FlexarParserINF             = 58
	FlexarParserTUPLE           = 59
	FlexarParserMAP             = 60
	FlexarParserERROR           = 61
	FlexarParserNULL            = 62
	FlexarParserANY             = 63
	FlexarParserDYN             = 64
	FlexarParserTEMPLATE_STRING = 65
	FlexarParserDEFAULT_STRING  = 66
	FlexarParserDISCARD         = 67
	FlexarParserNAME            = 68
	FlexarParserCOMMA           = 69
	FlexarParserDOT             = 70
	FlexarParserCOLON           = 71
	FlexarParserDOUBLE_COLON    = 72
	FlexarParserARROW           = 73
	FlexarParserSEMICOLON       = 74
	FlexarParserOPEN_PAREN      = 75
	FlexarParserCLOSE_PAREN     = 76
	FlexarParserOPEN_BRACE      = 77
	FlexarParserCLOSE_BRACE     = 78
	FlexarParserOPEN_BRACKET    = 79
	FlexarParserCLOSE_BRACKET   = 80
	FlexarParserASSIGN          = 81
	FlexarParserPLUS_ASSIGN     = 82
	FlexarParserMINUS_ASSIGN    = 83
	FlexarParserSTAR_ASSIGN     = 84
	FlexarParserMODULE_ASSIGN   = 85
	FlexarParserDIV_ASSIGN      = 86
	FlexarParserEXP_ASSIGN      = 87
	FlexarParserAND_ASSIGN      = 88
	FlexarParserOR_ASSIGN       = 89
	FlexarParserXOR_ASSIGN      = 90
	FlexarParserSHL_ASSIGN      = 91
	FlexarParserSHR_ASSIGN      = 92
	FlexarParserINF_ASSIGN      = 93
	FlexarParserEQUAL           = 94
	FlexarParserNOT_EQUAL       = 95
	FlexarParserLESS            = 96
	FlexarParserLESS_EQUAL      = 97
	FlexarParserGREATER         = 98
	FlexarParserGREATER_EQUAL   = 99
	FlexarParserAND             = 100
	FlexarParserOR              = 101
	FlexarParserXOR             = 102
	FlexarParserNOT             = 103
	FlexarParserBIT_AND         = 104
	FlexarParserBIT_OR          = 105
	FlexarParserBIT_XOR         = 106
	FlexarParserBIT_NOT         = 107
	FlexarParserSHL             = 108
	FlexarParserSHR             = 109
	FlexarParserPLUS            = 110
	FlexarParserMINUS           = 111
	FlexarParserSTAR            = 112
	FlexarParserEXP             = 113
	FlexarParserMODULE          = 114
	FlexarParserDIV             = 115
	FlexarParserINC             = 116
	FlexarParserDEC             = 117
	FlexarParserQUESTION        = 118
	FlexarParserRANGE           = 119
	FlexarParserSPREAD          = 120
	FlexarParserINT_NUM         = 121
	FlexarParserFLOAT_NUM       = 122
	FlexarParserCOMMENT         = 123
	FlexarParserWS              = 124
)

// FlexarParser rules.
const (
	FlexarParserRULE_program                = 0
	FlexarParserRULE_program_rule           = 1
	FlexarParserRULE_import_group           = 2
	FlexarParserRULE_import_rule            = 3
	FlexarParserRULE_import_namespace       = 4
	FlexarParserRULE_namespace_name         = 5
	FlexarParserRULE_namespace              = 6
	FlexarParserRULE_namespace_call         = 7
	FlexarParserRULE_class                  = 8
	FlexarParserRULE_class_extends          = 9
	FlexarParserRULE_class_implements       = 10
	FlexarParserRULE_class_body             = 11
	FlexarParserRULE_class_attribute        = 12
	FlexarParserRULE_privacy_modifier       = 13
	FlexarParserRULE_class_method           = 14
	FlexarParserRULE_abstract_method        = 15
	FlexarParserRULE_class_modifier         = 16
	FlexarParserRULE_constructor            = 17
	FlexarParserRULE_class_new_instance     = 18
	FlexarParserRULE_method_call            = 19
	FlexarParserRULE_attribute_call         = 20
	FlexarParserRULE_interface              = 21
	FlexarParserRULE_interface_extends      = 22
	FlexarParserRULE_interface_body         = 23
	FlexarParserRULE_interface_body_rule    = 24
	FlexarParserRULE_interface_method       = 25
	FlexarParserRULE_interface_attribute    = 26
	FlexarParserRULE_struct                 = 27
	FlexarParserRULE_struct_body            = 28
	FlexarParserRULE_struct_attribute       = 29
	FlexarParserRULE_enum                   = 30
	FlexarParserRULE_enum_body              = 31
	FlexarParserRULE_enum_attribute         = 32
	FlexarParserRULE_expression             = 33
	FlexarParserRULE_composed_value         = 34
	FlexarParserRULE_list_value             = 35
	FlexarParserRULE_map_value              = 36
	FlexarParserRULE_tuple_value            = 37
	FlexarParserRULE_named_tuple_value      = 38
	FlexarParserRULE_and_expression         = 39
	FlexarParserRULE_or_expression          = 40
	FlexarParserRULE_xor_expression         = 41
	FlexarParserRULE_not_expression         = 42
	FlexarParserRULE_expression_math        = 43
	FlexarParserRULE_term_math              = 44
	FlexarParserRULE_factor_math            = 45
	FlexarParserRULE_bitwise_math           = 46
	FlexarParserRULE_shift_math             = 47
	FlexarParserRULE_unary_math             = 48
	FlexarParserRULE_before_unary           = 49
	FlexarParserRULE_after_unary            = 50
	FlexarParserRULE_math_value             = 51
	FlexarParserRULE_parenthesis_expression = 52
	FlexarParserRULE_bitwise_operator       = 53
	FlexarParserRULE_shift_operator         = 54
	FlexarParserRULE_term_operator          = 55
	FlexarParserRULE_factor_operator        = 56
	FlexarParserRULE_comparision_operator   = 57
	FlexarParserRULE_value                  = 58
	FlexarParserRULE_statement              = 59
	FlexarParserRULE_new_scope              = 60
	FlexarParserRULE_for_statement          = 61
	FlexarParserRULE_for_rule               = 62
	FlexarParserRULE_for_in                 = 63
	FlexarParserRULE_full_for               = 64
	FlexarParserRULE_while_statement        = 65
	FlexarParserRULE_do_while_statement     = 66
	FlexarParserRULE_switch_statement       = 67
	FlexarParserRULE_switch_case            = 68
	FlexarParserRULE_try_statement          = 69
	FlexarParserRULE_catch_statement        = 70
	FlexarParserRULE_finally_statement      = 71
	FlexarParserRULE_if_statement           = 72
	FlexarParserRULE_elif_statement         = 73
	FlexarParserRULE_else_statement         = 74
	FlexarParserRULE_struct_func            = 75
	FlexarParserRULE_func                   = 76
	FlexarParserRULE_anonymous_func         = 77
	FlexarParserRULE_func_param             = 78
	FlexarParserRULE_func_callback          = 79
	FlexarParserRULE_func_param_callback    = 80
	FlexarParserRULE_func_param_rule        = 81
	FlexarParserRULE_func_call              = 82
	FlexarParserRULE_func_call_params       = 83
	FlexarParserRULE_func_return            = 84
	FlexarParserRULE_func_body              = 85
	FlexarParserRULE_return_statement       = 86
	FlexarParserRULE_variable_declaration   = 87
	FlexarParserRULE_variable_assign        = 88
	FlexarParserRULE_variable_name          = 89
	FlexarParserRULE_assing                 = 90
	FlexarParserRULE_type                   = 91
	FlexarParserRULE_final_type             = 92
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Namespace() INamespaceContext
	AllImport_group() []IImport_groupContext
	Import_group(i int) IImport_groupContext
	AllProgram_rule() []IProgram_ruleContext
	Program_rule(i int) IProgram_ruleContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Namespace() INamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceContext)
}

func (s *ProgramContext) AllImport_group() []IImport_groupContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImport_groupContext); ok {
			len++
		}
	}

	tst := make([]IImport_groupContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImport_groupContext); ok {
			tst[i] = t.(IImport_groupContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Import_group(i int) IImport_groupContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_groupContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_groupContext)
}

func (s *ProgramContext) AllProgram_rule() []IProgram_ruleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProgram_ruleContext); ok {
			len++
		}
	}

	tst := make([]IProgram_ruleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProgram_ruleContext); ok {
			tst[i] = t.(IProgram_ruleContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Program_rule(i int) IProgram_ruleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgram_ruleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgram_ruleContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, FlexarParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserIMPORT {
		{
			p.SetState(186)
			p.Import_group()
		}

		p.SetState(191)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(192)
		p.Namespace()
	}
	p.SetState(196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1064456) != 0) || _la == FlexarParserOPEN_PAREN {
		{
			p.SetState(193)
			p.Program_rule()
		}

		p.SetState(198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgram_ruleContext is an interface to support dynamic dispatch.
type IProgram_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class() IClassContext
	Func_() IFuncContext
	Interface_() IInterfaceContext
	Struct_() IStructContext
	Struct_func() IStruct_funcContext
	Enum() IEnumContext
	EXPORT() antlr.TerminalNode

	// IsProgram_ruleContext differentiates from other interfaces.
	IsProgram_ruleContext()
}

type Program_ruleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgram_ruleContext() *Program_ruleContext {
	var p = new(Program_ruleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_program_rule
	return p
}

func InitEmptyProgram_ruleContext(p *Program_ruleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_program_rule
}

func (*Program_ruleContext) IsProgram_ruleContext() {}

func NewProgram_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Program_ruleContext {
	var p = new(Program_ruleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_program_rule

	return p
}

func (s *Program_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Program_ruleContext) Class() IClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassContext)
}

func (s *Program_ruleContext) Func_() IFuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncContext)
}

func (s *Program_ruleContext) Interface_() IInterfaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceContext)
}

func (s *Program_ruleContext) Struct_() IStructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructContext)
}

func (s *Program_ruleContext) Struct_func() IStruct_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_funcContext)
}

func (s *Program_ruleContext) Enum() IEnumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumContext)
}

func (s *Program_ruleContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(FlexarParserEXPORT, 0)
}

func (s *Program_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Program_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Program_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterProgram_rule(s)
	}
}

func (s *Program_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitProgram_rule(s)
	}
}

func (s *Program_ruleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitProgram_rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Program_rule() (localctx IProgram_ruleContext) {
	localctx = NewProgram_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, FlexarParserRULE_program_rule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserEXPORT {
		{
			p.SetState(199)
			p.Match(FlexarParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserCLASS, FlexarParserABSTRACT:
		{
			p.SetState(202)
			p.Class()
		}

	case FlexarParserFUNC:
		{
			p.SetState(203)
			p.Func_()
		}

	case FlexarParserINTERFACE:
		{
			p.SetState(204)
			p.Interface_()
		}

	case FlexarParserSTRUCT:
		{
			p.SetState(205)
			p.Struct_()
		}

	case FlexarParserOPEN_PAREN:
		{
			p.SetState(206)
			p.Struct_func()
		}

	case FlexarParserENUM:
		{
			p.SetState(207)
			p.Enum()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_groupContext is an interface to support dynamic dispatch.
type IImport_groupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	Import_rule() IImport_ruleContext

	// IsImport_groupContext differentiates from other interfaces.
	IsImport_groupContext()
}

type Import_groupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_groupContext() *Import_groupContext {
	var p = new(Import_groupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_import_group
	return p
}

func InitEmptyImport_groupContext(p *Import_groupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_import_group
}

func (*Import_groupContext) IsImport_groupContext() {}

func NewImport_groupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_groupContext {
	var p = new(Import_groupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_import_group

	return p
}

func (s *Import_groupContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_groupContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(FlexarParserIMPORT, 0)
}

func (s *Import_groupContext) Import_rule() IImport_ruleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_ruleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_ruleContext)
}

func (s *Import_groupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_groupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_groupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterImport_group(s)
	}
}

func (s *Import_groupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitImport_group(s)
	}
}

func (s *Import_groupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitImport_group(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Import_group() (localctx IImport_groupContext) {
	localctx = NewImport_groupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, FlexarParserRULE_import_group)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(FlexarParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(211)
		p.Import_rule()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_ruleContext is an interface to support dynamic dispatch.
type IImport_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImport_namespace() []IImport_namespaceContext
	Import_namespace(i int) IImport_namespaceContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllUSE() []antlr.TerminalNode
	USE(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImport_ruleContext differentiates from other interfaces.
	IsImport_ruleContext()
}

type Import_ruleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_ruleContext() *Import_ruleContext {
	var p = new(Import_ruleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_import_rule
	return p
}

func InitEmptyImport_ruleContext(p *Import_ruleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_import_rule
}

func (*Import_ruleContext) IsImport_ruleContext() {}

func NewImport_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_ruleContext {
	var p = new(Import_ruleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_import_rule

	return p
}

func (s *Import_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_ruleContext) AllImport_namespace() []IImport_namespaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImport_namespaceContext); ok {
			len++
		}
	}

	tst := make([]IImport_namespaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImport_namespaceContext); ok {
			tst[i] = t.(IImport_namespaceContext)
			i++
		}
	}

	return tst
}

func (s *Import_ruleContext) Import_namespace(i int) IImport_namespaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImport_namespaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImport_namespaceContext)
}

func (s *Import_ruleContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserSEMICOLON)
}

func (s *Import_ruleContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserSEMICOLON, i)
}

func (s *Import_ruleContext) AllUSE() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserUSE)
}

func (s *Import_ruleContext) USE(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserUSE, i)
}

func (s *Import_ruleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Import_ruleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Import_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterImport_rule(s)
	}
}

func (s *Import_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitImport_rule(s)
	}
}

func (s *Import_ruleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitImport_rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Import_rule() (localctx IImport_ruleContext) {
	localctx = NewImport_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, FlexarParserRULE_import_rule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == FlexarParserUSE || _la == FlexarParserNAME {
		p.SetState(214)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlexarParserUSE {
			{
				p.SetState(213)
				p.Match(FlexarParserUSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(216)
			p.Import_namespace()
		}
		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(217)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlexarParserUSE {
				{
					p.SetState(218)
					p.Match(FlexarParserUSE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(222)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == FlexarParserNAME {
				{
					p.SetState(221)
					p.Import_namespace()
				}

			}

			p.SetState(228)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(229)
			p.Match(FlexarParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImport_namespaceContext is an interface to support dynamic dispatch.
type IImport_namespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Namespace_name() INamespace_nameContext
	DOUBLE_COLON() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImport_namespaceContext differentiates from other interfaces.
	IsImport_namespaceContext()
}

type Import_namespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_namespaceContext() *Import_namespaceContext {
	var p = new(Import_namespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_import_namespace
	return p
}

func InitEmptyImport_namespaceContext(p *Import_namespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_import_namespace
}

func (*Import_namespaceContext) IsImport_namespaceContext() {}

func NewImport_namespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_namespaceContext {
	var p = new(Import_namespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_import_namespace

	return p
}

func (s *Import_namespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_namespaceContext) Namespace_name() INamespace_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespace_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Import_namespaceContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserDOUBLE_COLON, 0)
}

func (s *Import_namespaceContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Import_namespaceContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Import_namespaceContext) AS() antlr.TerminalNode {
	return s.GetToken(FlexarParserAS, 0)
}

func (s *Import_namespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_namespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_namespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterImport_namespace(s)
	}
}

func (s *Import_namespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitImport_namespace(s)
	}
}

func (s *Import_namespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitImport_namespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Import_namespace() (localctx IImport_namespaceContext) {
	localctx = NewImport_namespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, FlexarParserRULE_import_namespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(235)
		p.Namespace_name()
	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserDOUBLE_COLON {
		{
			p.SetState(236)
			p.Match(FlexarParserDOUBLE_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(237)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserAS {
		{
			p.SetState(240)
			p.Match(FlexarParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespace_nameContext is an interface to support dynamic dispatch.
type INamespace_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsNamespace_nameContext differentiates from other interfaces.
	IsNamespace_nameContext()
}

type Namespace_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_nameContext() *Namespace_nameContext {
	var p = new(Namespace_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_namespace_name
	return p
}

func InitEmptyNamespace_nameContext(p *Namespace_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_namespace_name
}

func (*Namespace_nameContext) IsNamespace_nameContext() {}

func NewNamespace_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_nameContext {
	var p = new(Namespace_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_namespace_name

	return p
}

func (s *Namespace_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_nameContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Namespace_nameContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Namespace_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserDOT)
}

func (s *Namespace_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserDOT, i)
}

func (s *Namespace_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterNamespace_name(s)
	}
}

func (s *Namespace_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitNamespace_name(s)
	}
}

func (s *Namespace_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitNamespace_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Namespace_name() (localctx INamespace_nameContext) {
	localctx = NewNamespace_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, FlexarParserRULE_namespace_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(244)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserDOT {
		{
			p.SetState(245)
			p.Match(FlexarParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(246)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceContext is an interface to support dynamic dispatch.
type INamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAMESPACE() antlr.TerminalNode
	Namespace_name() INamespace_nameContext
	SEMICOLON() antlr.TerminalNode

	// IsNamespaceContext differentiates from other interfaces.
	IsNamespaceContext()
}

type NamespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceContext() *NamespaceContext {
	var p = new(NamespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_namespace
	return p
}

func InitEmptyNamespaceContext(p *NamespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_namespace
}

func (*NamespaceContext) IsNamespaceContext() {}

func NewNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceContext {
	var p = new(NamespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_namespace

	return p
}

func (s *NamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceContext) NAMESPACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAMESPACE, 0)
}

func (s *NamespaceContext) Namespace_name() INamespace_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespace_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *NamespaceContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserSEMICOLON, 0)
}

func (s *NamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterNamespace(s)
	}
}

func (s *NamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitNamespace(s)
	}
}

func (s *NamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Namespace() (localctx INamespaceContext) {
	localctx = NewNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, FlexarParserRULE_namespace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.Match(FlexarParserNAMESPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(253)
		p.Namespace_name()
	}
	{
		p.SetState(254)
		p.Match(FlexarParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespace_callContext is an interface to support dynamic dispatch.
type INamespace_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_COLON() antlr.TerminalNode
	Namespace_name() INamespace_nameContext
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	Func_call() IFunc_callContext

	// IsNamespace_callContext differentiates from other interfaces.
	IsNamespace_callContext()
}

type Namespace_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_callContext() *Namespace_callContext {
	var p = new(Namespace_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_namespace_call
	return p
}

func InitEmptyNamespace_callContext(p *Namespace_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_namespace_call
}

func (*Namespace_callContext) IsNamespace_callContext() {}

func NewNamespace_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_callContext {
	var p = new(Namespace_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_namespace_call

	return p
}

func (s *Namespace_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_callContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserDOUBLE_COLON, 0)
}

func (s *Namespace_callContext) Namespace_name() INamespace_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespace_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Namespace_callContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Namespace_callContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Namespace_callContext) Func_call() IFunc_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_callContext)
}

func (s *Namespace_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterNamespace_call(s)
	}
}

func (s *Namespace_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitNamespace_call(s)
	}
}

func (s *Namespace_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitNamespace_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Namespace_call() (localctx INamespace_callContext) {
	localctx = NewNamespace_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, FlexarParserRULE_namespace_call)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(256)
			p.Namespace_name()
		}

	case 2:
		{
			p.SetState(257)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(260)
		p.Match(FlexarParserDOUBLE_COLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(261)
			p.Func_call()
		}

	case 2:
		{
			p.SetState(262)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassContext is an interface to support dynamic dispatch.
type IClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	NAME() antlr.TerminalNode
	Class_body() IClass_bodyContext
	ABSTRACT() antlr.TerminalNode
	Class_extends() IClass_extendsContext
	Class_implements() IClass_implementsContext

	// IsClassContext differentiates from other interfaces.
	IsClassContext()
}

type ClassContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassContext() *ClassContext {
	var p = new(ClassContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class
	return p
}

func InitEmptyClassContext(p *ClassContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class
}

func (*ClassContext) IsClassContext() {}

func NewClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassContext {
	var p = new(ClassContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class

	return p
}

func (s *ClassContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassContext) CLASS() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLASS, 0)
}

func (s *ClassContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *ClassContext) Class_body() IClass_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_bodyContext)
}

func (s *ClassContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(FlexarParserABSTRACT, 0)
}

func (s *ClassContext) Class_extends() IClass_extendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_extendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_extendsContext)
}

func (s *ClassContext) Class_implements() IClass_implementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_implementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_implementsContext)
}

func (s *ClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass(s)
	}
}

func (s *ClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass(s)
	}
}

func (s *ClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class() (localctx IClassContext) {
	localctx = NewClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, FlexarParserRULE_class)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserABSTRACT {
		{
			p.SetState(265)
			p.Match(FlexarParserABSTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(268)
		p.Match(FlexarParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(269)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserEXTENDS {
		{
			p.SetState(270)
			p.Class_extends()
		}

	}
	p.SetState(274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserIMPLEMENTS {
		{
			p.SetState(273)
			p.Class_implements()
		}

	}
	{
		p.SetState(276)
		p.Class_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_extendsContext is an interface to support dynamic dispatch.
type IClass_extendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENDS() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClass_extendsContext differentiates from other interfaces.
	IsClass_extendsContext()
}

type Class_extendsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_extendsContext() *Class_extendsContext {
	var p = new(Class_extendsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_extends
	return p
}

func InitEmptyClass_extendsContext(p *Class_extendsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_extends
}

func (*Class_extendsContext) IsClass_extendsContext() {}

func NewClass_extendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_extendsContext {
	var p = new(Class_extendsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_extends

	return p
}

func (s *Class_extendsContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_extendsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(FlexarParserEXTENDS, 0)
}

func (s *Class_extendsContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Class_extendsContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Class_extendsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Class_extendsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Class_extendsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Class_extendsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Class_extendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_extendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_extendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_extends(s)
	}
}

func (s *Class_extendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_extends(s)
	}
}

func (s *Class_extendsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_extends(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_extends() (localctx IClass_extendsContext) {
	localctx = NewClass_extendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, FlexarParserRULE_class_extends)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(278)
		p.Match(FlexarParserEXTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserNAME:
		{
			p.SetState(279)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlexarParserOPEN_PAREN:
		{
			p.SetState(280)
			p.Match(FlexarParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(281)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(282)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(283)
				p.Match(FlexarParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(288)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(289)
			p.Match(FlexarParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_implementsContext is an interface to support dynamic dispatch.
type IClass_implementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPLEMENTS() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClass_implementsContext differentiates from other interfaces.
	IsClass_implementsContext()
}

type Class_implementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_implementsContext() *Class_implementsContext {
	var p = new(Class_implementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_implements
	return p
}

func InitEmptyClass_implementsContext(p *Class_implementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_implements
}

func (*Class_implementsContext) IsClass_implementsContext() {}

func NewClass_implementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_implementsContext {
	var p = new(Class_implementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_implements

	return p
}

func (s *Class_implementsContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_implementsContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(FlexarParserIMPLEMENTS, 0)
}

func (s *Class_implementsContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Class_implementsContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Class_implementsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Class_implementsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Class_implementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Class_implementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Class_implementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_implementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_implementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_implements(s)
	}
}

func (s *Class_implementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_implements(s)
	}
}

func (s *Class_implementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_implements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_implements() (localctx IClass_implementsContext) {
	localctx = NewClass_implementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, FlexarParserRULE_class_implements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(292)
		p.Match(FlexarParserIMPLEMENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserNAME:
		{
			p.SetState(293)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlexarParserOPEN_PAREN:
		{
			p.SetState(294)
			p.Match(FlexarParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(295)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(296)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(297)
				p.Match(FlexarParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(302)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(303)
			p.Match(FlexarParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_bodyContext is an interface to support dynamic dispatch.
type IClass_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllClass_attribute() []IClass_attributeContext
	Class_attribute(i int) IClass_attributeContext
	AllConstructor() []IConstructorContext
	Constructor(i int) IConstructorContext
	AllClass_method() []IClass_methodContext
	Class_method(i int) IClass_methodContext

	// IsClass_bodyContext differentiates from other interfaces.
	IsClass_bodyContext()
}

type Class_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_bodyContext() *Class_bodyContext {
	var p = new(Class_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_body
	return p
}

func InitEmptyClass_bodyContext(p *Class_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_body
}

func (*Class_bodyContext) IsClass_bodyContext() {}

func NewClass_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_bodyContext {
	var p = new(Class_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_body

	return p
}

func (s *Class_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_bodyContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Class_bodyContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Class_bodyContext) AllClass_attribute() []IClass_attributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClass_attributeContext); ok {
			len++
		}
	}

	tst := make([]IClass_attributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClass_attributeContext); ok {
			tst[i] = t.(IClass_attributeContext)
			i++
		}
	}

	return tst
}

func (s *Class_bodyContext) Class_attribute(i int) IClass_attributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_attributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_attributeContext)
}

func (s *Class_bodyContext) AllConstructor() []IConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstructorContext); ok {
			len++
		}
	}

	tst := make([]IConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstructorContext); ok {
			tst[i] = t.(IConstructorContext)
			i++
		}
	}

	return tst
}

func (s *Class_bodyContext) Constructor(i int) IConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorContext)
}

func (s *Class_bodyContext) AllClass_method() []IClass_methodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClass_methodContext); ok {
			len++
		}
	}

	tst := make([]IClass_methodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClass_methodContext); ok {
			tst[i] = t.(IClass_methodContext)
			i++
		}
	}

	return tst
}

func (s *Class_bodyContext) Class_method(i int) IClass_methodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_methodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_methodContext)
}

func (s *Class_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_body(s)
	}
}

func (s *Class_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_body(s)
	}
}

func (s *Class_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_body() (localctx IClass_bodyContext) {
	localctx = NewClass_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, FlexarParserRULE_class_body)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(306)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(307)
				p.Class_attribute()
			}

		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(313)
				p.Constructor()
			}

		}
		p.SetState(318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&68727801856) != 0 {
		{
			p.SetState(319)
			p.Class_method()
		}

		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(325)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_attributeContext is an interface to support dynamic dispatch.
type IClass_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class_modifier() IClass_modifierContext
	Variable_declaration() IVariable_declarationContext

	// IsClass_attributeContext differentiates from other interfaces.
	IsClass_attributeContext()
}

type Class_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_attributeContext() *Class_attributeContext {
	var p = new(Class_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_attribute
	return p
}

func InitEmptyClass_attributeContext(p *Class_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_attribute
}

func (*Class_attributeContext) IsClass_attributeContext() {}

func NewClass_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_attributeContext {
	var p = new(Class_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_attribute

	return p
}

func (s *Class_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_attributeContext) Class_modifier() IClass_modifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_modifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_modifierContext)
}

func (s *Class_attributeContext) Variable_declaration() IVariable_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Class_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_attribute(s)
	}
}

func (s *Class_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_attribute(s)
	}
}

func (s *Class_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_attribute() (localctx IClass_attributeContext) {
	localctx = NewClass_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, FlexarParserRULE_class_attribute)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(327)
		p.Class_modifier()
	}
	{
		p.SetState(328)
		p.Variable_declaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivacy_modifierContext is an interface to support dynamic dispatch.
type IPrivacy_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUBLIC() antlr.TerminalNode
	PRIVATE() antlr.TerminalNode
	PROTECTED() antlr.TerminalNode

	// IsPrivacy_modifierContext differentiates from other interfaces.
	IsPrivacy_modifierContext()
}

type Privacy_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivacy_modifierContext() *Privacy_modifierContext {
	var p = new(Privacy_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_privacy_modifier
	return p
}

func InitEmptyPrivacy_modifierContext(p *Privacy_modifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_privacy_modifier
}

func (*Privacy_modifierContext) IsPrivacy_modifierContext() {}

func NewPrivacy_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Privacy_modifierContext {
	var p = new(Privacy_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_privacy_modifier

	return p
}

func (s *Privacy_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Privacy_modifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(FlexarParserPUBLIC, 0)
}

func (s *Privacy_modifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(FlexarParserPRIVATE, 0)
}

func (s *Privacy_modifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(FlexarParserPROTECTED, 0)
}

func (s *Privacy_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Privacy_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Privacy_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterPrivacy_modifier(s)
	}
}

func (s *Privacy_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitPrivacy_modifier(s)
	}
}

func (s *Privacy_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitPrivacy_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Privacy_modifier() (localctx IPrivacy_modifierContext) {
	localctx = NewPrivacy_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, FlexarParserRULE_privacy_modifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(330)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&458752) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_methodContext is an interface to support dynamic dispatch.
type IClass_methodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class_modifier() IClass_modifierContext
	Func_() IFuncContext
	Abstract_method() IAbstract_methodContext

	// IsClass_methodContext differentiates from other interfaces.
	IsClass_methodContext()
}

type Class_methodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_methodContext() *Class_methodContext {
	var p = new(Class_methodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_method
	return p
}

func InitEmptyClass_methodContext(p *Class_methodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_method
}

func (*Class_methodContext) IsClass_methodContext() {}

func NewClass_methodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_methodContext {
	var p = new(Class_methodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_method

	return p
}

func (s *Class_methodContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_methodContext) Class_modifier() IClass_modifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_modifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_modifierContext)
}

func (s *Class_methodContext) Func_() IFuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncContext)
}

func (s *Class_methodContext) Abstract_method() IAbstract_methodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstract_methodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstract_methodContext)
}

func (s *Class_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_methodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_method(s)
	}
}

func (s *Class_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_method(s)
	}
}

func (s *Class_methodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_method(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_method() (localctx IClass_methodContext) {
	localctx = NewClass_methodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, FlexarParserRULE_class_method)
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(332)
			p.Class_modifier()
		}
		{
			p.SetState(333)
			p.Func_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(335)
			p.Abstract_method()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbstract_methodContext is an interface to support dynamic dispatch.
type IAbstract_methodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ABSTRACT() antlr.TerminalNode
	FUNC() antlr.TerminalNode
	NAME() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_param() IFunc_paramContext
	Func_return() IFunc_returnContext

	// IsAbstract_methodContext differentiates from other interfaces.
	IsAbstract_methodContext()
}

type Abstract_methodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstract_methodContext() *Abstract_methodContext {
	var p = new(Abstract_methodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_abstract_method
	return p
}

func InitEmptyAbstract_methodContext(p *Abstract_methodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_abstract_method
}

func (*Abstract_methodContext) IsAbstract_methodContext() {}

func NewAbstract_methodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Abstract_methodContext {
	var p = new(Abstract_methodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_abstract_method

	return p
}

func (s *Abstract_methodContext) GetParser() antlr.Parser { return s.parser }

func (s *Abstract_methodContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(FlexarParserABSTRACT, 0)
}

func (s *Abstract_methodContext) FUNC() antlr.TerminalNode {
	return s.GetToken(FlexarParserFUNC, 0)
}

func (s *Abstract_methodContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Abstract_methodContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Abstract_methodContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Abstract_methodContext) Func_param() IFunc_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *Abstract_methodContext) Func_return() IFunc_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_returnContext)
}

func (s *Abstract_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Abstract_methodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Abstract_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterAbstract_method(s)
	}
}

func (s *Abstract_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitAbstract_method(s)
	}
}

func (s *Abstract_methodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitAbstract_method(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Abstract_method() (localctx IAbstract_methodContext) {
	localctx = NewAbstract_methodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, FlexarParserRULE_abstract_method)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(338)
		p.Match(FlexarParserABSTRACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(339)
		p.Match(FlexarParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(340)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(341)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserNAME {
		{
			p.SetState(342)
			p.Func_param()
		}

	}
	{
		p.SetState(345)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(346)
			p.Func_return()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_modifierContext is an interface to support dynamic dispatch.
type IClass_modifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READONLY() antlr.TerminalNode
	Privacy_modifier() IPrivacy_modifierContext
	STATIC() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	OVERRIDE() antlr.TerminalNode
	ABSTRACT() antlr.TerminalNode

	// IsClass_modifierContext differentiates from other interfaces.
	IsClass_modifierContext()
}

type Class_modifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_modifierContext() *Class_modifierContext {
	var p = new(Class_modifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_modifier
	return p
}

func InitEmptyClass_modifierContext(p *Class_modifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_modifier
}

func (*Class_modifierContext) IsClass_modifierContext() {}

func NewClass_modifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_modifierContext {
	var p = new(Class_modifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_modifier

	return p
}

func (s *Class_modifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_modifierContext) READONLY() antlr.TerminalNode {
	return s.GetToken(FlexarParserREADONLY, 0)
}

func (s *Class_modifierContext) Privacy_modifier() IPrivacy_modifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivacy_modifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivacy_modifierContext)
}

func (s *Class_modifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(FlexarParserSTATIC, 0)
}

func (s *Class_modifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(FlexarParserFINAL, 0)
}

func (s *Class_modifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOVERRIDE, 0)
}

func (s *Class_modifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(FlexarParserABSTRACT, 0)
}

func (s *Class_modifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_modifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_modifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_modifier(s)
	}
}

func (s *Class_modifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_modifier(s)
	}
}

func (s *Class_modifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_modifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_modifier() (localctx IClass_modifierContext) {
	localctx = NewClass_modifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, FlexarParserRULE_class_modifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserABSTRACT || _la == FlexarParserOVERRIDE {
		{
			p.SetState(349)
			_la = p.GetTokenStream().LA(1)

			if !(_la == FlexarParserABSTRACT || _la == FlexarParserOVERRIDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserREADONLY {
		{
			p.SetState(352)
			p.Match(FlexarParserREADONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&458752) != 0 {
		{
			p.SetState(355)
			p.Privacy_modifier()
		}

	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserSTATIC {
		{
			p.SetState(358)
			p.Match(FlexarParserSTATIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserFINAL {
		{
			p.SetState(361)
			p.Match(FlexarParserFINAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorContext is an interface to support dynamic dispatch.
type IConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_body() IFunc_bodyContext
	Privacy_modifier() IPrivacy_modifierContext
	Func_param() IFunc_paramContext

	// IsConstructorContext differentiates from other interfaces.
	IsConstructorContext()
}

type ConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorContext() *ConstructorContext {
	var p = new(ConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_constructor
	return p
}

func InitEmptyConstructorContext(p *ConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_constructor
}

func (*ConstructorContext) IsConstructorContext() {}

func NewConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorContext {
	var p = new(ConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_constructor

	return p
}

func (s *ConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *ConstructorContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *ConstructorContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *ConstructorContext) Func_body() IFunc_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_bodyContext)
}

func (s *ConstructorContext) Privacy_modifier() IPrivacy_modifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivacy_modifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivacy_modifierContext)
}

func (s *ConstructorContext) Func_param() IFunc_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *ConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterConstructor(s)
	}
}

func (s *ConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitConstructor(s)
	}
}

func (s *ConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Constructor() (localctx IConstructorContext) {
	localctx = NewConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, FlexarParserRULE_constructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&458752) != 0 {
		{
			p.SetState(364)
			p.Privacy_modifier()
		}

	}
	{
		p.SetState(367)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(368)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserNAME {
		{
			p.SetState(369)
			p.Func_param()
		}

	}
	{
		p.SetState(372)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(373)
		p.Func_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClass_new_instanceContext is an interface to support dynamic dispatch.
type IClass_new_instanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NEW() antlr.TerminalNode
	Func_call() IFunc_callContext
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClass_new_instanceContext differentiates from other interfaces.
	IsClass_new_instanceContext()
}

type Class_new_instanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_new_instanceContext() *Class_new_instanceContext {
	var p = new(Class_new_instanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_new_instance
	return p
}

func InitEmptyClass_new_instanceContext(p *Class_new_instanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_class_new_instance
}

func (*Class_new_instanceContext) IsClass_new_instanceContext() {}

func NewClass_new_instanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_new_instanceContext {
	var p = new(Class_new_instanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_class_new_instance

	return p
}

func (s *Class_new_instanceContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_new_instanceContext) NEW() antlr.TerminalNode {
	return s.GetToken(FlexarParserNEW, 0)
}

func (s *Class_new_instanceContext) Func_call() IFunc_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_callContext)
}

func (s *Class_new_instanceContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Class_new_instanceContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Class_new_instanceContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Class_new_instanceContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Class_new_instanceContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserASSIGN)
}

func (s *Class_new_instanceContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserASSIGN, i)
}

func (s *Class_new_instanceContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Class_new_instanceContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Class_new_instanceContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Class_new_instanceContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Class_new_instanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_new_instanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_new_instanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterClass_new_instance(s)
	}
}

func (s *Class_new_instanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitClass_new_instance(s)
	}
}

func (s *Class_new_instanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitClass_new_instance(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Class_new_instance() (localctx IClass_new_instanceContext) {
	localctx = NewClass_new_instanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, FlexarParserRULE_class_new_instance)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(375)
		p.Match(FlexarParserNEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(376)
			p.Func_call()
		}

	case 2:
		{
			p.SetState(377)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(378)
			p.Match(FlexarParserOPEN_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlexarParserNAME {
			{
				p.SetState(379)
				p.Match(FlexarParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(380)
				p.Match(FlexarParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(381)
				p.expression(0)
			}
			p.SetState(388)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == FlexarParserCOMMA {
				{
					p.SetState(382)
					p.Match(FlexarParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(383)
					p.Match(FlexarParserNAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(384)
					p.Match(FlexarParserASSIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(385)
					p.expression(0)
				}

				p.SetState(390)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(393)
			p.Match(FlexarParserCLOSE_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethod_callContext is an interface to support dynamic dispatch.
type IMethod_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Func_call() IFunc_callContext
	THIS() antlr.TerminalNode
	Variable_name() IVariable_nameContext

	// IsMethod_callContext differentiates from other interfaces.
	IsMethod_callContext()
}

type Method_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethod_callContext() *Method_callContext {
	var p = new(Method_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_method_call
	return p
}

func InitEmptyMethod_callContext(p *Method_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_method_call
}

func (*Method_callContext) IsMethod_callContext() {}

func NewMethod_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Method_callContext {
	var p = new(Method_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_method_call

	return p
}

func (s *Method_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Method_callContext) DOT() antlr.TerminalNode {
	return s.GetToken(FlexarParserDOT, 0)
}

func (s *Method_callContext) Func_call() IFunc_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_callContext)
}

func (s *Method_callContext) THIS() antlr.TerminalNode {
	return s.GetToken(FlexarParserTHIS, 0)
}

func (s *Method_callContext) Variable_name() IVariable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_nameContext)
}

func (s *Method_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Method_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Method_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterMethod_call(s)
	}
}

func (s *Method_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitMethod_call(s)
	}
}

func (s *Method_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitMethod_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Method_call() (localctx IMethod_callContext) {
	localctx = NewMethod_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, FlexarParserRULE_method_call)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(396)
			p.Match(FlexarParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(397)
			p.Variable_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(400)
		p.Match(FlexarParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(401)
		p.Func_call()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttribute_callContext is an interface to support dynamic dispatch.
type IAttribute_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllFunc_call() []IFunc_callContext
	Func_call(i int) IFunc_callContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsAttribute_callContext differentiates from other interfaces.
	IsAttribute_callContext()
}

type Attribute_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_callContext() *Attribute_callContext {
	var p = new(Attribute_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_attribute_call
	return p
}

func InitEmptyAttribute_callContext(p *Attribute_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_attribute_call
}

func (*Attribute_callContext) IsAttribute_callContext() {}

func NewAttribute_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_callContext {
	var p = new(Attribute_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_attribute_call

	return p
}

func (s *Attribute_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_callContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Attribute_callContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Attribute_callContext) AllFunc_call() []IFunc_callContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunc_callContext); ok {
			len++
		}
	}

	tst := make([]IFunc_callContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunc_callContext); ok {
			tst[i] = t.(IFunc_callContext)
			i++
		}
	}

	return tst
}

func (s *Attribute_callContext) Func_call(i int) IFunc_callContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_callContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_callContext)
}

func (s *Attribute_callContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserDOT)
}

func (s *Attribute_callContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserDOT, i)
}

func (s *Attribute_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterAttribute_call(s)
	}
}

func (s *Attribute_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitAttribute_call(s)
	}
}

func (s *Attribute_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitAttribute_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Attribute_call() (localctx IAttribute_callContext) {
	localctx = NewAttribute_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, FlexarParserRULE_attribute_call)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(403)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(404)
			p.Func_call()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case FlexarParserDOT:
				{
					p.SetState(407)
					p.Match(FlexarParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(408)
					p.Match(FlexarParserNAME)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case FlexarParserNAME:
				{
					p.SetState(409)
					p.Func_call()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceContext is an interface to support dynamic dispatch.
type IInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	Interface_body() IInterface_bodyContext
	Interface_extends() IInterface_extendsContext

	// IsInterfaceContext differentiates from other interfaces.
	IsInterfaceContext()
}

type InterfaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceContext() *InterfaceContext {
	var p = new(InterfaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface
	return p
}

func InitEmptyInterfaceContext(p *InterfaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface
}

func (*InterfaceContext) IsInterfaceContext() {}

func NewInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceContext {
	var p = new(InterfaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_interface

	return p
}

func (s *InterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserINTERFACE, 0)
}

func (s *InterfaceContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *InterfaceContext) Interface_body() IInterface_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterface_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterface_bodyContext)
}

func (s *InterfaceContext) Interface_extends() IInterface_extendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterface_extendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterface_extendsContext)
}

func (s *InterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterInterface(s)
	}
}

func (s *InterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitInterface(s)
	}
}

func (s *InterfaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitInterface(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Interface_() (localctx IInterfaceContext) {
	localctx = NewInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, FlexarParserRULE_interface)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(FlexarParserINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(416)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserEXTENDS {
		{
			p.SetState(417)
			p.Interface_extends()
		}

	}
	{
		p.SetState(420)
		p.Interface_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterface_extendsContext is an interface to support dynamic dispatch.
type IInterface_extendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENDS() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInterface_extendsContext differentiates from other interfaces.
	IsInterface_extendsContext()
}

type Interface_extendsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_extendsContext() *Interface_extendsContext {
	var p = new(Interface_extendsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_extends
	return p
}

func InitEmptyInterface_extendsContext(p *Interface_extendsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_extends
}

func (*Interface_extendsContext) IsInterface_extendsContext() {}

func NewInterface_extendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_extendsContext {
	var p = new(Interface_extendsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_interface_extends

	return p
}

func (s *Interface_extendsContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_extendsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(FlexarParserEXTENDS, 0)
}

func (s *Interface_extendsContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Interface_extendsContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Interface_extendsContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Interface_extendsContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Interface_extendsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Interface_extendsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Interface_extendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_extendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_extendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterInterface_extends(s)
	}
}

func (s *Interface_extendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitInterface_extends(s)
	}
}

func (s *Interface_extendsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitInterface_extends(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Interface_extends() (localctx IInterface_extendsContext) {
	localctx = NewInterface_extendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, FlexarParserRULE_interface_extends)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(FlexarParserEXTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserNAME:
		{
			p.SetState(423)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlexarParserOPEN_PAREN:
		{
			p.SetState(424)
			p.Match(FlexarParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(425)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(426)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(427)
				p.Match(FlexarParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(432)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(433)
			p.Match(FlexarParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterface_bodyContext is an interface to support dynamic dispatch.
type IInterface_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllInterface_body_rule() []IInterface_body_ruleContext
	Interface_body_rule(i int) IInterface_body_ruleContext

	// IsInterface_bodyContext differentiates from other interfaces.
	IsInterface_bodyContext()
}

type Interface_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_bodyContext() *Interface_bodyContext {
	var p = new(Interface_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_body
	return p
}

func InitEmptyInterface_bodyContext(p *Interface_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_body
}

func (*Interface_bodyContext) IsInterface_bodyContext() {}

func NewInterface_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_bodyContext {
	var p = new(Interface_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_interface_body

	return p
}

func (s *Interface_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_bodyContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Interface_bodyContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Interface_bodyContext) AllInterface_body_rule() []IInterface_body_ruleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterface_body_ruleContext); ok {
			len++
		}
	}

	tst := make([]IInterface_body_ruleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterface_body_ruleContext); ok {
			tst[i] = t.(IInterface_body_ruleContext)
			i++
		}
	}

	return tst
}

func (s *Interface_bodyContext) Interface_body_rule(i int) IInterface_body_ruleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterface_body_ruleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterface_body_ruleContext)
}

func (s *Interface_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterInterface_body(s)
	}
}

func (s *Interface_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitInterface_body(s)
	}
}

func (s *Interface_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitInterface_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Interface_body() (localctx IInterface_bodyContext) {
	localctx = NewInterface_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, FlexarParserRULE_interface_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserFUNC || _la == FlexarParserNAME {
		{
			p.SetState(437)
			p.Interface_body_rule()
		}

		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(443)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterface_body_ruleContext is an interface to support dynamic dispatch.
type IInterface_body_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Interface_method() IInterface_methodContext
	Interface_attribute() IInterface_attributeContext

	// IsInterface_body_ruleContext differentiates from other interfaces.
	IsInterface_body_ruleContext()
}

type Interface_body_ruleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_body_ruleContext() *Interface_body_ruleContext {
	var p = new(Interface_body_ruleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_body_rule
	return p
}

func InitEmptyInterface_body_ruleContext(p *Interface_body_ruleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_body_rule
}

func (*Interface_body_ruleContext) IsInterface_body_ruleContext() {}

func NewInterface_body_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_body_ruleContext {
	var p = new(Interface_body_ruleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_interface_body_rule

	return p
}

func (s *Interface_body_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_body_ruleContext) Interface_method() IInterface_methodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterface_methodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterface_methodContext)
}

func (s *Interface_body_ruleContext) Interface_attribute() IInterface_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterface_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterface_attributeContext)
}

func (s *Interface_body_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_body_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_body_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterInterface_body_rule(s)
	}
}

func (s *Interface_body_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitInterface_body_rule(s)
	}
}

func (s *Interface_body_ruleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitInterface_body_rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Interface_body_rule() (localctx IInterface_body_ruleContext) {
	localctx = NewInterface_body_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, FlexarParserRULE_interface_body_rule)
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserFUNC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.Interface_method()
		}

	case FlexarParserNAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.Interface_attribute()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterface_methodContext is an interface to support dynamic dispatch.
type IInterface_methodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	NAME() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_param() IFunc_paramContext
	Func_return() IFunc_returnContext

	// IsInterface_methodContext differentiates from other interfaces.
	IsInterface_methodContext()
}

type Interface_methodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_methodContext() *Interface_methodContext {
	var p = new(Interface_methodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_method
	return p
}

func InitEmptyInterface_methodContext(p *Interface_methodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_method
}

func (*Interface_methodContext) IsInterface_methodContext() {}

func NewInterface_methodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_methodContext {
	var p = new(Interface_methodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_interface_method

	return p
}

func (s *Interface_methodContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_methodContext) FUNC() antlr.TerminalNode {
	return s.GetToken(FlexarParserFUNC, 0)
}

func (s *Interface_methodContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Interface_methodContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Interface_methodContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Interface_methodContext) Func_param() IFunc_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *Interface_methodContext) Func_return() IFunc_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_returnContext)
}

func (s *Interface_methodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_methodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_methodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterInterface_method(s)
	}
}

func (s *Interface_methodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitInterface_method(s)
	}
}

func (s *Interface_methodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitInterface_method(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Interface_method() (localctx IInterface_methodContext) {
	localctx = NewInterface_methodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, FlexarParserRULE_interface_method)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(FlexarParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(450)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(451)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserNAME {
		{
			p.SetState(452)
			p.Func_param()
		}

	}
	{
		p.SetState(455)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(456)
			p.Func_return()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterface_attributeContext is an interface to support dynamic dispatch.
type IInterface_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsInterface_attributeContext differentiates from other interfaces.
	IsInterface_attributeContext()
}

type Interface_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_attributeContext() *Interface_attributeContext {
	var p = new(Interface_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_attribute
	return p
}

func InitEmptyInterface_attributeContext(p *Interface_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_interface_attribute
}

func (*Interface_attributeContext) IsInterface_attributeContext() {}

func NewInterface_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_attributeContext {
	var p = new(Interface_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_interface_attribute

	return p
}

func (s *Interface_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_attributeContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Interface_attributeContext) COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, 0)
}

func (s *Interface_attributeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Interface_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterInterface_attribute(s)
	}
}

func (s *Interface_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitInterface_attribute(s)
	}
}

func (s *Interface_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitInterface_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Interface_attribute() (localctx IInterface_attributeContext) {
	localctx = NewInterface_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, FlexarParserRULE_interface_attribute)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(460)
		p.Match(FlexarParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(461)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructContext is an interface to support dynamic dispatch.
type IStructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	NAME() antlr.TerminalNode
	Struct_body() IStruct_bodyContext

	// IsStructContext differentiates from other interfaces.
	IsStructContext()
}

type StructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructContext() *StructContext {
	var p = new(StructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct
	return p
}

func InitEmptyStructContext(p *StructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct
}

func (*StructContext) IsStructContext() {}

func NewStructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructContext {
	var p = new(StructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_struct

	return p
}

func (s *StructContext) GetParser() antlr.Parser { return s.parser }

func (s *StructContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(FlexarParserSTRUCT, 0)
}

func (s *StructContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *StructContext) Struct_body() IStruct_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_bodyContext)
}

func (s *StructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterStruct(s)
	}
}

func (s *StructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitStruct(s)
	}
}

func (s *StructContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitStruct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Struct_() (localctx IStructContext) {
	localctx = NewStructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, FlexarParserRULE_struct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(463)
		p.Match(FlexarParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(464)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(465)
		p.Struct_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_bodyContext is an interface to support dynamic dispatch.
type IStruct_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStruct_attribute() []IStruct_attributeContext
	Struct_attribute(i int) IStruct_attributeContext

	// IsStruct_bodyContext differentiates from other interfaces.
	IsStruct_bodyContext()
}

type Struct_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_bodyContext() *Struct_bodyContext {
	var p = new(Struct_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct_body
	return p
}

func InitEmptyStruct_bodyContext(p *Struct_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct_body
}

func (*Struct_bodyContext) IsStruct_bodyContext() {}

func NewStruct_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_bodyContext {
	var p = new(Struct_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_struct_body

	return p
}

func (s *Struct_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_bodyContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Struct_bodyContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Struct_bodyContext) AllStruct_attribute() []IStruct_attributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStruct_attributeContext); ok {
			len++
		}
	}

	tst := make([]IStruct_attributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStruct_attributeContext); ok {
			tst[i] = t.(IStruct_attributeContext)
			i++
		}
	}

	return tst
}

func (s *Struct_bodyContext) Struct_attribute(i int) IStruct_attributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStruct_attributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStruct_attributeContext)
}

func (s *Struct_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterStruct_body(s)
	}
}

func (s *Struct_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitStruct_body(s)
	}
}

func (s *Struct_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitStruct_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Struct_body() (localctx IStruct_bodyContext) {
	localctx = NewStruct_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, FlexarParserRULE_struct_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserNAME {
		{
			p.SetState(468)
			p.Struct_attribute()
		}

		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(474)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_attributeContext is an interface to support dynamic dispatch.
type IStruct_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable_declaration() IVariable_declarationContext

	// IsStruct_attributeContext differentiates from other interfaces.
	IsStruct_attributeContext()
}

type Struct_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_attributeContext() *Struct_attributeContext {
	var p = new(Struct_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct_attribute
	return p
}

func InitEmptyStruct_attributeContext(p *Struct_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct_attribute
}

func (*Struct_attributeContext) IsStruct_attributeContext() {}

func NewStruct_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_attributeContext {
	var p = new(Struct_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_struct_attribute

	return p
}

func (s *Struct_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_attributeContext) Variable_declaration() IVariable_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Struct_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterStruct_attribute(s)
	}
}

func (s *Struct_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitStruct_attribute(s)
	}
}

func (s *Struct_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitStruct_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Struct_attribute() (localctx IStruct_attributeContext) {
	localctx = NewStruct_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, FlexarParserRULE_struct_attribute)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Variable_declaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumContext is an interface to support dynamic dispatch.
type IEnumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	NAME() antlr.TerminalNode
	Enum_body() IEnum_bodyContext

	// IsEnumContext differentiates from other interfaces.
	IsEnumContext()
}

type EnumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumContext() *EnumContext {
	var p = new(EnumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_enum
	return p
}

func InitEmptyEnumContext(p *EnumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_enum
}

func (*EnumContext) IsEnumContext() {}

func NewEnumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumContext {
	var p = new(EnumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_enum

	return p
}

func (s *EnumContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(FlexarParserENUM, 0)
}

func (s *EnumContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *EnumContext) Enum_body() IEnum_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnum_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnum_bodyContext)
}

func (s *EnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterEnum(s)
	}
}

func (s *EnumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitEnum(s)
	}
}

func (s *EnumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitEnum(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Enum() (localctx IEnumContext) {
	localctx = NewEnumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, FlexarParserRULE_enum)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Match(FlexarParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(479)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(480)
		p.Enum_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnum_bodyContext is an interface to support dynamic dispatch.
type IEnum_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllEnum_attribute() []IEnum_attributeContext
	Enum_attribute(i int) IEnum_attributeContext

	// IsEnum_bodyContext differentiates from other interfaces.
	IsEnum_bodyContext()
}

type Enum_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_bodyContext() *Enum_bodyContext {
	var p = new(Enum_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_enum_body
	return p
}

func InitEmptyEnum_bodyContext(p *Enum_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_enum_body
}

func (*Enum_bodyContext) IsEnum_bodyContext() {}

func NewEnum_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_bodyContext {
	var p = new(Enum_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_enum_body

	return p
}

func (s *Enum_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_bodyContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Enum_bodyContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Enum_bodyContext) AllEnum_attribute() []IEnum_attributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnum_attributeContext); ok {
			len++
		}
	}

	tst := make([]IEnum_attributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnum_attributeContext); ok {
			tst[i] = t.(IEnum_attributeContext)
			i++
		}
	}

	return tst
}

func (s *Enum_bodyContext) Enum_attribute(i int) IEnum_attributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnum_attributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnum_attributeContext)
}

func (s *Enum_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterEnum_body(s)
	}
}

func (s *Enum_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitEnum_body(s)
	}
}

func (s *Enum_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitEnum_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Enum_body() (localctx IEnum_bodyContext) {
	localctx = NewEnum_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, FlexarParserRULE_enum_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserNAME {
		{
			p.SetState(483)
			p.Enum_attribute()
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(489)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnum_attributeContext is an interface to support dynamic dispatch.
type IEnum_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	INT_NUM() antlr.TerminalNode

	// IsEnum_attributeContext differentiates from other interfaces.
	IsEnum_attributeContext()
}

type Enum_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_attributeContext() *Enum_attributeContext {
	var p = new(Enum_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_enum_attribute
	return p
}

func InitEmptyEnum_attributeContext(p *Enum_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_enum_attribute
}

func (*Enum_attributeContext) IsEnum_attributeContext() {}

func NewEnum_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_attributeContext {
	var p = new(Enum_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_enum_attribute

	return p
}

func (s *Enum_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_attributeContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Enum_attributeContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserASSIGN, 0)
}

func (s *Enum_attributeContext) INT_NUM() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT_NUM, 0)
}

func (s *Enum_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterEnum_attribute(s)
	}
}

func (s *Enum_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitEnum_attribute(s)
	}
}

func (s *Enum_attributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitEnum_attribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Enum_attribute() (localctx IEnum_attributeContext) {
	localctx = NewEnum_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, FlexarParserRULE_enum_attribute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserASSIGN {
		{
			p.SetState(492)
			p.Match(FlexarParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(493)
			p.Match(FlexarParserINT_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class_new_instance() IClass_new_instanceContext
	Func_call() IFunc_callContext
	Anonymous_func() IAnonymous_funcContext
	Value() IValueContext
	Method_call() IMethod_callContext
	Namespace_call() INamespace_callContext
	Attribute_call() IAttribute_callContext
	Expression_math() IExpression_mathContext
	Composed_value() IComposed_valueContext
	And_expression() IAnd_expressionContext
	OPEN_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	CLOSE_PAREN() antlr.TerminalNode
	Type_() ITypeContext
	NAME() antlr.TerminalNode
	NULL() antlr.TerminalNode
	Comparision_operator() IComparision_operatorContext
	QUESTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	IS() antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Class_new_instance() IClass_new_instanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClass_new_instanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClass_new_instanceContext)
}

func (s *ExpressionContext) Func_call() IFunc_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_callContext)
}

func (s *ExpressionContext) Anonymous_func() IAnonymous_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymous_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymous_funcContext)
}

func (s *ExpressionContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *ExpressionContext) Method_call() IMethod_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethod_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethod_callContext)
}

func (s *ExpressionContext) Namespace_call() INamespace_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespace_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespace_callContext)
}

func (s *ExpressionContext) Attribute_call() IAttribute_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttribute_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttribute_callContext)
}

func (s *ExpressionContext) Expression_math() IExpression_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_mathContext)
}

func (s *ExpressionContext) Composed_value() IComposed_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComposed_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComposed_valueContext)
}

func (s *ExpressionContext) And_expression() IAnd_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *ExpressionContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *ExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ExpressionContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *ExpressionContext) NULL() antlr.TerminalNode {
	return s.GetToken(FlexarParserNULL, 0)
}

func (s *ExpressionContext) Comparision_operator() IComparision_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparision_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparision_operatorContext)
}

func (s *ExpressionContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(FlexarParserQUESTION, 0)
}

func (s *ExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, 0)
}

func (s *ExpressionContext) RANGE() antlr.TerminalNode {
	return s.GetToken(FlexarParserRANGE, 0)
}

func (s *ExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(FlexarParserIS, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *FlexarParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 66
	p.EnterRecursionRule(localctx, 66, FlexarParserRULE_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(497)
			p.Class_new_instance()
		}

	case 2:
		{
			p.SetState(498)
			p.Func_call()
		}

	case 3:
		{
			p.SetState(499)
			p.Anonymous_func()
		}

	case 4:
		{
			p.SetState(500)
			p.Value()
		}

	case 5:
		{
			p.SetState(501)
			p.Method_call()
		}

	case 6:
		{
			p.SetState(502)
			p.Namespace_call()
		}

	case 7:
		{
			p.SetState(503)
			p.Attribute_call()
		}

	case 8:
		{
			p.SetState(504)
			p.expression_math(0)
		}

	case 9:
		{
			p.SetState(505)
			p.Composed_value()
		}

	case 10:
		{
			p.SetState(506)
			p.and_expression(0)
		}

	case 11:
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(507)
				p.Type_()
			}

		case 2:
			{
				p.SetState(508)
				p.Match(FlexarParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(511)
			p.Match(FlexarParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.expression(0)
		}
		{
			p.SetState(513)
			p.Match(FlexarParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		{
			p.SetState(515)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		{
			p.SetState(516)
			p.Match(FlexarParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(535)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_expression)
				p.SetState(519)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(520)
					p.Comparision_operator()
				}
				{
					p.SetState(521)
					p.expression(7)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_expression)
				p.SetState(523)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(524)
					p.Match(FlexarParserQUESTION)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(525)
					p.expression(0)
				}
				{
					p.SetState(526)
					p.Match(FlexarParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(527)
					p.expression(6)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_expression)
				p.SetState(529)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(530)
					p.Match(FlexarParserRANGE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(531)
					p.expression(5)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_expression)
				p.SetState(532)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(533)
					p.Match(FlexarParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(534)
					p.Type_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComposed_valueContext is an interface to support dynamic dispatch.
type IComposed_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	List_value() IList_valueContext
	Map_value() IMap_valueContext
	Tuple_value() ITuple_valueContext
	Named_tuple_value() INamed_tuple_valueContext

	// IsComposed_valueContext differentiates from other interfaces.
	IsComposed_valueContext()
}

type Composed_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComposed_valueContext() *Composed_valueContext {
	var p = new(Composed_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_composed_value
	return p
}

func InitEmptyComposed_valueContext(p *Composed_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_composed_value
}

func (*Composed_valueContext) IsComposed_valueContext() {}

func NewComposed_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Composed_valueContext {
	var p = new(Composed_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_composed_value

	return p
}

func (s *Composed_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Composed_valueContext) List_value() IList_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IList_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IList_valueContext)
}

func (s *Composed_valueContext) Map_value() IMap_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMap_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMap_valueContext)
}

func (s *Composed_valueContext) Tuple_value() ITuple_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITuple_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITuple_valueContext)
}

func (s *Composed_valueContext) Named_tuple_value() INamed_tuple_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamed_tuple_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamed_tuple_valueContext)
}

func (s *Composed_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Composed_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Composed_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterComposed_value(s)
	}
}

func (s *Composed_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitComposed_value(s)
	}
}

func (s *Composed_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitComposed_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Composed_value() (localctx IComposed_valueContext) {
	localctx = NewComposed_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, FlexarParserRULE_composed_value)
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(540)
			p.List_value()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(541)
			p.Map_value()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(542)
			p.Tuple_value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(543)
			p.Named_tuple_value()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IList_valueContext is an interface to support dynamic dispatch.
type IList_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsList_valueContext differentiates from other interfaces.
	IsList_valueContext()
}

type List_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_valueContext() *List_valueContext {
	var p = new(List_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_list_value
	return p
}

func InitEmptyList_valueContext(p *List_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_list_value
}

func (*List_valueContext) IsList_valueContext() {}

func NewList_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_valueContext {
	var p = new(List_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_list_value

	return p
}

func (s *List_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *List_valueContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *List_valueContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *List_valueContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *List_valueContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *List_valueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *List_valueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *List_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterList_value(s)
	}
}

func (s *List_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitList_value(s)
	}
}

func (s *List_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitList_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) List_value() (localctx IList_valueContext) {
	localctx = NewList_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, FlexarParserRULE_list_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(546)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(547)
			p.expression(0)
		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(548)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(549)
				p.expression(0)
			}

			p.SetState(554)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(557)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMap_valueContext is an interface to support dynamic dispatch.
type IMap_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMap_valueContext differentiates from other interfaces.
	IsMap_valueContext()
}

type Map_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_valueContext() *Map_valueContext {
	var p = new(Map_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_map_value
	return p
}

func InitEmptyMap_valueContext(p *Map_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_map_value
}

func (*Map_valueContext) IsMap_valueContext() {}

func NewMap_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_valueContext {
	var p = new(Map_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_map_value

	return p
}

func (s *Map_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_valueContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Map_valueContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Map_valueContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Map_valueContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Map_valueContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOLON)
}

func (s *Map_valueContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, i)
}

func (s *Map_valueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Map_valueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Map_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Map_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterMap_value(s)
	}
}

func (s *Map_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitMap_value(s)
	}
}

func (s *Map_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitMap_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Map_value() (localctx IMap_valueContext) {
	localctx = NewMap_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, FlexarParserRULE_map_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(560)
			p.expression(0)
		}
		{
			p.SetState(561)
			p.Match(FlexarParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(562)
			p.expression(0)
		}
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(563)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(564)
				p.expression(0)
			}
			{
				p.SetState(565)
				p.Match(FlexarParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(566)
				p.expression(0)
			}

			p.SetState(572)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(575)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITuple_valueContext is an interface to support dynamic dispatch.
type ITuple_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTuple_valueContext differentiates from other interfaces.
	IsTuple_valueContext()
}

type Tuple_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTuple_valueContext() *Tuple_valueContext {
	var p = new(Tuple_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_tuple_value
	return p
}

func InitEmptyTuple_valueContext(p *Tuple_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_tuple_value
}

func (*Tuple_valueContext) IsTuple_valueContext() {}

func NewTuple_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tuple_valueContext {
	var p = new(Tuple_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_tuple_value

	return p
}

func (s *Tuple_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Tuple_valueContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Tuple_valueContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Tuple_valueContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Tuple_valueContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Tuple_valueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Tuple_valueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Tuple_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tuple_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tuple_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterTuple_value(s)
	}
}

func (s *Tuple_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitTuple_value(s)
	}
}

func (s *Tuple_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitTuple_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Tuple_value() (localctx ITuple_valueContext) {
	localctx = NewTuple_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, FlexarParserRULE_tuple_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(577)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(578)
			p.expression(0)
		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(579)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(580)
				p.expression(0)
			}

			p.SetState(585)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(588)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamed_tuple_valueContext is an interface to support dynamic dispatch.
type INamed_tuple_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamed_tuple_valueContext differentiates from other interfaces.
	IsNamed_tuple_valueContext()
}

type Named_tuple_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_tuple_valueContext() *Named_tuple_valueContext {
	var p = new(Named_tuple_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_named_tuple_value
	return p
}

func InitEmptyNamed_tuple_valueContext(p *Named_tuple_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_named_tuple_value
}

func (*Named_tuple_valueContext) IsNamed_tuple_valueContext() {}

func NewNamed_tuple_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_tuple_valueContext {
	var p = new(Named_tuple_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_named_tuple_value

	return p
}

func (s *Named_tuple_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_tuple_valueContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Named_tuple_valueContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Named_tuple_valueContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Named_tuple_valueContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Named_tuple_valueContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOLON)
}

func (s *Named_tuple_valueContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, i)
}

func (s *Named_tuple_valueContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Named_tuple_valueContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Named_tuple_valueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Named_tuple_valueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Named_tuple_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_tuple_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_tuple_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterNamed_tuple_value(s)
	}
}

func (s *Named_tuple_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitNamed_tuple_value(s)
	}
}

func (s *Named_tuple_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitNamed_tuple_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Named_tuple_value() (localctx INamed_tuple_valueContext) {
	localctx = NewNamed_tuple_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, FlexarParserRULE_named_tuple_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserNAME {
		{
			p.SetState(591)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(592)
			p.Match(FlexarParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.expression(0)
		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(594)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(595)
				p.Match(FlexarParserNAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(596)
				p.Match(FlexarParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(597)
				p.expression(0)
			}

			p.SetState(602)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(605)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnd_expressionContext is an interface to support dynamic dispatch.
type IAnd_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Or_expression() IOr_expressionContext
	And_expression() IAnd_expressionContext
	AND() antlr.TerminalNode

	// IsAnd_expressionContext differentiates from other interfaces.
	IsAnd_expressionContext()
}

type And_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_expressionContext() *And_expressionContext {
	var p = new(And_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_and_expression
	return p
}

func InitEmptyAnd_expressionContext(p *And_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_and_expression
}

func (*And_expressionContext) IsAnd_expressionContext() {}

func NewAnd_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_expressionContext {
	var p = new(And_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_and_expression

	return p
}

func (s *And_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *And_expressionContext) Or_expression() IOr_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_expressionContext)
}

func (s *And_expressionContext) And_expression() IAnd_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnd_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *And_expressionContext) AND() antlr.TerminalNode {
	return s.GetToken(FlexarParserAND, 0)
}

func (s *And_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterAnd_expression(s)
	}
}

func (s *And_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitAnd_expression(s)
	}
}

func (s *And_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitAnd_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) And_expression() (localctx IAnd_expressionContext) {
	return p.and_expression(0)
}

func (p *FlexarParser) and_expression(_p int) (localctx IAnd_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAnd_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAnd_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 78
	p.EnterRecursionRule(localctx, 78, FlexarParserRULE_and_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.or_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAnd_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_and_expression)
			p.SetState(610)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(611)
				p.Match(FlexarParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(612)
				p.or_expression(0)
			}

		}
		p.SetState(617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOr_expressionContext is an interface to support dynamic dispatch.
type IOr_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Xor_expression() IXor_expressionContext
	Or_expression() IOr_expressionContext
	OR() antlr.TerminalNode

	// IsOr_expressionContext differentiates from other interfaces.
	IsOr_expressionContext()
}

type Or_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_expressionContext() *Or_expressionContext {
	var p = new(Or_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_or_expression
	return p
}

func InitEmptyOr_expressionContext(p *Or_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_or_expression
}

func (*Or_expressionContext) IsOr_expressionContext() {}

func NewOr_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_expressionContext {
	var p = new(Or_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_or_expression

	return p
}

func (s *Or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_expressionContext) Xor_expression() IXor_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXor_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXor_expressionContext)
}

func (s *Or_expressionContext) Or_expression() IOr_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOr_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOr_expressionContext)
}

func (s *Or_expressionContext) OR() antlr.TerminalNode {
	return s.GetToken(FlexarParserOR, 0)
}

func (s *Or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterOr_expression(s)
	}
}

func (s *Or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitOr_expression(s)
	}
}

func (s *Or_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitOr_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Or_expression() (localctx IOr_expressionContext) {
	return p.or_expression(0)
}

func (p *FlexarParser) or_expression(_p int) (localctx IOr_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewOr_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IOr_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 80
	p.EnterRecursionRule(localctx, 80, FlexarParserRULE_or_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.xor_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewOr_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_or_expression)
			p.SetState(621)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(622)
				p.Match(FlexarParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(623)
				p.xor_expression(0)
			}

		}
		p.SetState(628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXor_expressionContext is an interface to support dynamic dispatch.
type IXor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Not_expression() INot_expressionContext
	Xor_expression() IXor_expressionContext
	XOR() antlr.TerminalNode

	// IsXor_expressionContext differentiates from other interfaces.
	IsXor_expressionContext()
}

type Xor_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_expressionContext() *Xor_expressionContext {
	var p = new(Xor_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_xor_expression
	return p
}

func InitEmptyXor_expressionContext(p *Xor_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_xor_expression
}

func (*Xor_expressionContext) IsXor_expressionContext() {}

func NewXor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_expressionContext {
	var p = new(Xor_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_xor_expression

	return p
}

func (s *Xor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_expressionContext) Not_expression() INot_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot_expressionContext)
}

func (s *Xor_expressionContext) Xor_expression() IXor_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXor_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXor_expressionContext)
}

func (s *Xor_expressionContext) XOR() antlr.TerminalNode {
	return s.GetToken(FlexarParserXOR, 0)
}

func (s *Xor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterXor_expression(s)
	}
}

func (s *Xor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitXor_expression(s)
	}
}

func (s *Xor_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitXor_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Xor_expression() (localctx IXor_expressionContext) {
	return p.xor_expression(0)
}

func (p *FlexarParser) xor_expression(_p int) (localctx IXor_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewXor_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IXor_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 82
	p.EnterRecursionRule(localctx, 82, FlexarParserRULE_xor_expression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(630)
		p.Not_expression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewXor_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_xor_expression)
			p.SetState(632)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(633)
				p.Match(FlexarParserXOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(634)
				p.Not_expression()
			}

		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INot_expressionContext is an interface to support dynamic dispatch.
type INot_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	Not_expression() INot_expressionContext
	BOOLEAN() antlr.TerminalNode

	// IsNot_expressionContext differentiates from other interfaces.
	IsNot_expressionContext()
}

type Not_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot_expressionContext() *Not_expressionContext {
	var p = new(Not_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_not_expression
	return p
}

func InitEmptyNot_expressionContext(p *Not_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_not_expression
}

func (*Not_expressionContext) IsNot_expressionContext() {}

func NewNot_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not_expressionContext {
	var p = new(Not_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_not_expression

	return p
}

func (s *Not_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Not_expressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(FlexarParserNOT, 0)
}

func (s *Not_expressionContext) Not_expression() INot_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot_expressionContext)
}

func (s *Not_expressionContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(FlexarParserBOOLEAN, 0)
}

func (s *Not_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterNot_expression(s)
	}
}

func (s *Not_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitNot_expression(s)
	}
}

func (s *Not_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitNot_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Not_expression() (localctx INot_expressionContext) {
	localctx = NewNot_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, FlexarParserRULE_not_expression)
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(640)
			p.Match(FlexarParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(641)
			p.Not_expression()
		}

	case FlexarParserBOOLEAN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(642)
			p.Match(FlexarParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpression_mathContext is an interface to support dynamic dispatch.
type IExpression_mathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Term_math() ITerm_mathContext
	Expression_math() IExpression_mathContext
	Factor_operator() IFactor_operatorContext

	// IsExpression_mathContext differentiates from other interfaces.
	IsExpression_mathContext()
}

type Expression_mathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_mathContext() *Expression_mathContext {
	var p = new(Expression_mathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_expression_math
	return p
}

func InitEmptyExpression_mathContext(p *Expression_mathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_expression_math
}

func (*Expression_mathContext) IsExpression_mathContext() {}

func NewExpression_mathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_mathContext {
	var p = new(Expression_mathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_expression_math

	return p
}

func (s *Expression_mathContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_mathContext) Term_math() ITerm_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerm_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerm_mathContext)
}

func (s *Expression_mathContext) Expression_math() IExpression_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_mathContext)
}

func (s *Expression_mathContext) Factor_operator() IFactor_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactor_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactor_operatorContext)
}

func (s *Expression_mathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_mathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_mathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterExpression_math(s)
	}
}

func (s *Expression_mathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitExpression_math(s)
	}
}

func (s *Expression_mathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitExpression_math(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Expression_math() (localctx IExpression_mathContext) {
	return p.expression_math(0)
}

func (p *FlexarParser) expression_math(_p int) (localctx IExpression_mathContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpression_mathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpression_mathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, FlexarParserRULE_expression_math, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.term_math(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpression_mathContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_expression_math)
			p.SetState(648)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(649)
				p.Factor_operator()
			}
			{
				p.SetState(650)
				p.term_math(0)
			}

		}
		p.SetState(656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITerm_mathContext is an interface to support dynamic dispatch.
type ITerm_mathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor_math() IFactor_mathContext
	Term_math() ITerm_mathContext
	Term_operator() ITerm_operatorContext

	// IsTerm_mathContext differentiates from other interfaces.
	IsTerm_mathContext()
}

type Term_mathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerm_mathContext() *Term_mathContext {
	var p = new(Term_mathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_term_math
	return p
}

func InitEmptyTerm_mathContext(p *Term_mathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_term_math
}

func (*Term_mathContext) IsTerm_mathContext() {}

func NewTerm_mathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Term_mathContext {
	var p = new(Term_mathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_term_math

	return p
}

func (s *Term_mathContext) GetParser() antlr.Parser { return s.parser }

func (s *Term_mathContext) Factor_math() IFactor_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactor_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactor_mathContext)
}

func (s *Term_mathContext) Term_math() ITerm_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerm_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerm_mathContext)
}

func (s *Term_mathContext) Term_operator() ITerm_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerm_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerm_operatorContext)
}

func (s *Term_mathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Term_mathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Term_mathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterTerm_math(s)
	}
}

func (s *Term_mathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitTerm_math(s)
	}
}

func (s *Term_mathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitTerm_math(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Term_math() (localctx ITerm_mathContext) {
	return p.term_math(0)
}

func (p *FlexarParser) term_math(_p int) (localctx ITerm_mathContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTerm_mathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITerm_mathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 88
	p.EnterRecursionRule(localctx, 88, FlexarParserRULE_term_math, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.factor_math(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTerm_mathContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_term_math)
			p.SetState(660)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(661)
				p.Term_operator()
			}
			{
				p.SetState(662)
				p.factor_math(0)
			}

		}
		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactor_mathContext is an interface to support dynamic dispatch.
type IFactor_mathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bitwise_math() IBitwise_mathContext
	Factor_math() IFactor_mathContext
	EXP() antlr.TerminalNode

	// IsFactor_mathContext differentiates from other interfaces.
	IsFactor_mathContext()
}

type Factor_mathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactor_mathContext() *Factor_mathContext {
	var p = new(Factor_mathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_factor_math
	return p
}

func InitEmptyFactor_mathContext(p *Factor_mathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_factor_math
}

func (*Factor_mathContext) IsFactor_mathContext() {}

func NewFactor_mathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Factor_mathContext {
	var p = new(Factor_mathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_factor_math

	return p
}

func (s *Factor_mathContext) GetParser() antlr.Parser { return s.parser }

func (s *Factor_mathContext) Bitwise_math() IBitwise_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwise_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwise_mathContext)
}

func (s *Factor_mathContext) Factor_math() IFactor_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactor_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactor_mathContext)
}

func (s *Factor_mathContext) EXP() antlr.TerminalNode {
	return s.GetToken(FlexarParserEXP, 0)
}

func (s *Factor_mathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Factor_mathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Factor_mathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFactor_math(s)
	}
}

func (s *Factor_mathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFactor_math(s)
	}
}

func (s *Factor_mathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFactor_math(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Factor_math() (localctx IFactor_mathContext) {
	return p.factor_math(0)
}

func (p *FlexarParser) factor_math(_p int) (localctx IFactor_mathContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewFactor_mathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IFactor_mathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 90
	p.EnterRecursionRule(localctx, 90, FlexarParserRULE_factor_math, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.bitwise_math(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewFactor_mathContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_factor_math)
			p.SetState(672)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(673)
				p.Match(FlexarParserEXP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(674)
				p.bitwise_math(0)
			}

		}
		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwise_mathContext is an interface to support dynamic dispatch.
type IBitwise_mathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Shift_math() IShift_mathContext
	Bitwise_math() IBitwise_mathContext
	Bitwise_operator() IBitwise_operatorContext

	// IsBitwise_mathContext differentiates from other interfaces.
	IsBitwise_mathContext()
}

type Bitwise_mathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwise_mathContext() *Bitwise_mathContext {
	var p = new(Bitwise_mathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_bitwise_math
	return p
}

func InitEmptyBitwise_mathContext(p *Bitwise_mathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_bitwise_math
}

func (*Bitwise_mathContext) IsBitwise_mathContext() {}

func NewBitwise_mathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitwise_mathContext {
	var p = new(Bitwise_mathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_bitwise_math

	return p
}

func (s *Bitwise_mathContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitwise_mathContext) Shift_math() IShift_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_mathContext)
}

func (s *Bitwise_mathContext) Bitwise_math() IBitwise_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwise_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwise_mathContext)
}

func (s *Bitwise_mathContext) Bitwise_operator() IBitwise_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwise_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwise_operatorContext)
}

func (s *Bitwise_mathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitwise_mathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitwise_mathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterBitwise_math(s)
	}
}

func (s *Bitwise_mathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitBitwise_math(s)
	}
}

func (s *Bitwise_mathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitBitwise_math(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Bitwise_math() (localctx IBitwise_mathContext) {
	return p.bitwise_math(0)
}

func (p *FlexarParser) bitwise_math(_p int) (localctx IBitwise_mathContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwise_mathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwise_mathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 92
	p.EnterRecursionRule(localctx, 92, FlexarParserRULE_bitwise_math, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.shift_math(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwise_mathContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_bitwise_math)
			p.SetState(683)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(684)
				p.Bitwise_operator()
			}
			{
				p.SetState(685)
				p.shift_math(0)
			}

		}
		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShift_mathContext is an interface to support dynamic dispatch.
type IShift_mathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unary_math() IUnary_mathContext
	Shift_math() IShift_mathContext
	Shift_operator() IShift_operatorContext

	// IsShift_mathContext differentiates from other interfaces.
	IsShift_mathContext()
}

type Shift_mathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_mathContext() *Shift_mathContext {
	var p = new(Shift_mathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_shift_math
	return p
}

func InitEmptyShift_mathContext(p *Shift_mathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_shift_math
}

func (*Shift_mathContext) IsShift_mathContext() {}

func NewShift_mathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_mathContext {
	var p = new(Shift_mathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_shift_math

	return p
}

func (s *Shift_mathContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_mathContext) Unary_math() IUnary_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnary_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnary_mathContext)
}

func (s *Shift_mathContext) Shift_math() IShift_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_mathContext)
}

func (s *Shift_mathContext) Shift_operator() IShift_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShift_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShift_operatorContext)
}

func (s *Shift_mathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_mathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_mathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterShift_math(s)
	}
}

func (s *Shift_mathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitShift_math(s)
	}
}

func (s *Shift_mathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitShift_math(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Shift_math() (localctx IShift_mathContext) {
	return p.shift_math(0)
}

func (p *FlexarParser) shift_math(_p int) (localctx IShift_mathContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewShift_mathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShift_mathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 94
	p.EnterRecursionRule(localctx, 94, FlexarParserRULE_shift_math, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.Unary_math()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewShift_mathContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, FlexarParserRULE_shift_math)
			p.SetState(695)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(696)
				p.Shift_operator()
			}
			{
				p.SetState(697)
				p.Unary_math()
			}

		}
		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnary_mathContext is an interface to support dynamic dispatch.
type IUnary_mathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Before_unary() IBefore_unaryContext
	After_unary() IAfter_unaryContext
	Math_value() IMath_valueContext
	Parenthesis_expression() IParenthesis_expressionContext

	// IsUnary_mathContext differentiates from other interfaces.
	IsUnary_mathContext()
}

type Unary_mathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_mathContext() *Unary_mathContext {
	var p = new(Unary_mathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_unary_math
	return p
}

func InitEmptyUnary_mathContext(p *Unary_mathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_unary_math
}

func (*Unary_mathContext) IsUnary_mathContext() {}

func NewUnary_mathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_mathContext {
	var p = new(Unary_mathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_unary_math

	return p
}

func (s *Unary_mathContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_mathContext) Before_unary() IBefore_unaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBefore_unaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBefore_unaryContext)
}

func (s *Unary_mathContext) After_unary() IAfter_unaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAfter_unaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAfter_unaryContext)
}

func (s *Unary_mathContext) Math_value() IMath_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMath_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMath_valueContext)
}

func (s *Unary_mathContext) Parenthesis_expression() IParenthesis_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesis_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesis_expressionContext)
}

func (s *Unary_mathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_mathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_mathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterUnary_math(s)
	}
}

func (s *Unary_mathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitUnary_math(s)
	}
}

func (s *Unary_mathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitUnary_math(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Unary_math() (localctx IUnary_mathContext) {
	localctx = NewUnary_mathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, FlexarParserRULE_unary_math)
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.Before_unary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(705)
			p.After_unary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(706)
			p.Math_value()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(707)
			p.Parenthesis_expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBefore_unaryContext is an interface to support dynamic dispatch.
type IBefore_unaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INC() antlr.TerminalNode
	Math_value() IMath_valueContext
	DEC() antlr.TerminalNode
	BIT_NOT() antlr.TerminalNode

	// IsBefore_unaryContext differentiates from other interfaces.
	IsBefore_unaryContext()
}

type Before_unaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBefore_unaryContext() *Before_unaryContext {
	var p = new(Before_unaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_before_unary
	return p
}

func InitEmptyBefore_unaryContext(p *Before_unaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_before_unary
}

func (*Before_unaryContext) IsBefore_unaryContext() {}

func NewBefore_unaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Before_unaryContext {
	var p = new(Before_unaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_before_unary

	return p
}

func (s *Before_unaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Before_unaryContext) INC() antlr.TerminalNode {
	return s.GetToken(FlexarParserINC, 0)
}

func (s *Before_unaryContext) Math_value() IMath_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMath_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMath_valueContext)
}

func (s *Before_unaryContext) DEC() antlr.TerminalNode {
	return s.GetToken(FlexarParserDEC, 0)
}

func (s *Before_unaryContext) BIT_NOT() antlr.TerminalNode {
	return s.GetToken(FlexarParserBIT_NOT, 0)
}

func (s *Before_unaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Before_unaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Before_unaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterBefore_unary(s)
	}
}

func (s *Before_unaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitBefore_unary(s)
	}
}

func (s *Before_unaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitBefore_unary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Before_unary() (localctx IBefore_unaryContext) {
	localctx = NewBefore_unaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, FlexarParserRULE_before_unary)
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserINC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(710)
			p.Match(FlexarParserINC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(711)
			p.Math_value()
		}

	case FlexarParserDEC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Match(FlexarParserDEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(713)
			p.Math_value()
		}

	case FlexarParserBIT_NOT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(714)
			p.Match(FlexarParserBIT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(715)
			p.Math_value()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAfter_unaryContext is an interface to support dynamic dispatch.
type IAfter_unaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Math_value() IMath_valueContext
	INC() antlr.TerminalNode
	DEC() antlr.TerminalNode

	// IsAfter_unaryContext differentiates from other interfaces.
	IsAfter_unaryContext()
}

type After_unaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAfter_unaryContext() *After_unaryContext {
	var p = new(After_unaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_after_unary
	return p
}

func InitEmptyAfter_unaryContext(p *After_unaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_after_unary
}

func (*After_unaryContext) IsAfter_unaryContext() {}

func NewAfter_unaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *After_unaryContext {
	var p = new(After_unaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_after_unary

	return p
}

func (s *After_unaryContext) GetParser() antlr.Parser { return s.parser }

func (s *After_unaryContext) Math_value() IMath_valueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMath_valueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMath_valueContext)
}

func (s *After_unaryContext) INC() antlr.TerminalNode {
	return s.GetToken(FlexarParserINC, 0)
}

func (s *After_unaryContext) DEC() antlr.TerminalNode {
	return s.GetToken(FlexarParserDEC, 0)
}

func (s *After_unaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *After_unaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *After_unaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterAfter_unary(s)
	}
}

func (s *After_unaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitAfter_unary(s)
	}
}

func (s *After_unaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitAfter_unary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) After_unary() (localctx IAfter_unaryContext) {
	localctx = NewAfter_unaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, FlexarParserRULE_after_unary)
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(718)
			p.Math_value()
		}
		{
			p.SetState(719)
			p.Match(FlexarParserINC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)
			p.Math_value()
		}
		{
			p.SetState(722)
			p.Match(FlexarParserDEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMath_valueContext is an interface to support dynamic dispatch.
type IMath_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable_name() IVariable_nameContext
	INT_NUM() antlr.TerminalNode

	// IsMath_valueContext differentiates from other interfaces.
	IsMath_valueContext()
}

type Math_valueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMath_valueContext() *Math_valueContext {
	var p = new(Math_valueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_math_value
	return p
}

func InitEmptyMath_valueContext(p *Math_valueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_math_value
}

func (*Math_valueContext) IsMath_valueContext() {}

func NewMath_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Math_valueContext {
	var p = new(Math_valueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_math_value

	return p
}

func (s *Math_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Math_valueContext) Variable_name() IVariable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_nameContext)
}

func (s *Math_valueContext) INT_NUM() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT_NUM, 0)
}

func (s *Math_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Math_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Math_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterMath_value(s)
	}
}

func (s *Math_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitMath_value(s)
	}
}

func (s *Math_valueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitMath_value(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Math_value() (localctx IMath_valueContext) {
	localctx = NewMath_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, FlexarParserRULE_math_value)
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserTHIS, FlexarParserDISCARD, FlexarParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			p.Variable_name()
		}

	case FlexarParserINT_NUM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(727)
			p.Match(FlexarParserINT_NUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesis_expressionContext is an interface to support dynamic dispatch.
type IParenthesis_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	Expression_math() IExpression_mathContext
	CLOSE_PAREN() antlr.TerminalNode

	// IsParenthesis_expressionContext differentiates from other interfaces.
	IsParenthesis_expressionContext()
}

type Parenthesis_expressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesis_expressionContext() *Parenthesis_expressionContext {
	var p = new(Parenthesis_expressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_parenthesis_expression
	return p
}

func InitEmptyParenthesis_expressionContext(p *Parenthesis_expressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_parenthesis_expression
}

func (*Parenthesis_expressionContext) IsParenthesis_expressionContext() {}

func NewParenthesis_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parenthesis_expressionContext {
	var p = new(Parenthesis_expressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_parenthesis_expression

	return p
}

func (s *Parenthesis_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Parenthesis_expressionContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Parenthesis_expressionContext) Expression_math() IExpression_mathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpression_mathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpression_mathContext)
}

func (s *Parenthesis_expressionContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Parenthesis_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parenthesis_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parenthesis_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterParenthesis_expression(s)
	}
}

func (s *Parenthesis_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitParenthesis_expression(s)
	}
}

func (s *Parenthesis_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitParenthesis_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Parenthesis_expression() (localctx IParenthesis_expressionContext) {
	localctx = NewParenthesis_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, FlexarParserRULE_parenthesis_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.expression_math(0)
	}
	{
		p.SetState(732)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwise_operatorContext is an interface to support dynamic dispatch.
type IBitwise_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BIT_AND() antlr.TerminalNode
	BIT_OR() antlr.TerminalNode
	BIT_XOR() antlr.TerminalNode

	// IsBitwise_operatorContext differentiates from other interfaces.
	IsBitwise_operatorContext()
}

type Bitwise_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitwise_operatorContext() *Bitwise_operatorContext {
	var p = new(Bitwise_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_bitwise_operator
	return p
}

func InitEmptyBitwise_operatorContext(p *Bitwise_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_bitwise_operator
}

func (*Bitwise_operatorContext) IsBitwise_operatorContext() {}

func NewBitwise_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bitwise_operatorContext {
	var p = new(Bitwise_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_bitwise_operator

	return p
}

func (s *Bitwise_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bitwise_operatorContext) BIT_AND() antlr.TerminalNode {
	return s.GetToken(FlexarParserBIT_AND, 0)
}

func (s *Bitwise_operatorContext) BIT_OR() antlr.TerminalNode {
	return s.GetToken(FlexarParserBIT_OR, 0)
}

func (s *Bitwise_operatorContext) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(FlexarParserBIT_XOR, 0)
}

func (s *Bitwise_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bitwise_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bitwise_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterBitwise_operator(s)
	}
}

func (s *Bitwise_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitBitwise_operator(s)
	}
}

func (s *Bitwise_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitBitwise_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Bitwise_operator() (localctx IBitwise_operatorContext) {
	localctx = NewBitwise_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, FlexarParserRULE_bitwise_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShift_operatorContext is an interface to support dynamic dispatch.
type IShift_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHL() antlr.TerminalNode
	SHR() antlr.TerminalNode

	// IsShift_operatorContext differentiates from other interfaces.
	IsShift_operatorContext()
}

type Shift_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_operatorContext() *Shift_operatorContext {
	var p = new(Shift_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_shift_operator
	return p
}

func InitEmptyShift_operatorContext(p *Shift_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_shift_operator
}

func (*Shift_operatorContext) IsShift_operatorContext() {}

func NewShift_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_operatorContext {
	var p = new(Shift_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_shift_operator

	return p
}

func (s *Shift_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_operatorContext) SHL() antlr.TerminalNode {
	return s.GetToken(FlexarParserSHL, 0)
}

func (s *Shift_operatorContext) SHR() antlr.TerminalNode {
	return s.GetToken(FlexarParserSHR, 0)
}

func (s *Shift_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterShift_operator(s)
	}
}

func (s *Shift_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitShift_operator(s)
	}
}

func (s *Shift_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitShift_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Shift_operator() (localctx IShift_operatorContext) {
	localctx = NewShift_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, FlexarParserRULE_shift_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlexarParserSHL || _la == FlexarParserSHR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITerm_operatorContext is an interface to support dynamic dispatch.
type ITerm_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STAR() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MODULE() antlr.TerminalNode

	// IsTerm_operatorContext differentiates from other interfaces.
	IsTerm_operatorContext()
}

type Term_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerm_operatorContext() *Term_operatorContext {
	var p = new(Term_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_term_operator
	return p
}

func InitEmptyTerm_operatorContext(p *Term_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_term_operator
}

func (*Term_operatorContext) IsTerm_operatorContext() {}

func NewTerm_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Term_operatorContext {
	var p = new(Term_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_term_operator

	return p
}

func (s *Term_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Term_operatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(FlexarParserSTAR, 0)
}

func (s *Term_operatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(FlexarParserDIV, 0)
}

func (s *Term_operatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(FlexarParserMODULE, 0)
}

func (s *Term_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Term_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Term_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterTerm_operator(s)
	}
}

func (s *Term_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitTerm_operator(s)
	}
}

func (s *Term_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitTerm_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Term_operator() (localctx ITerm_operatorContext) {
	localctx = NewTerm_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, FlexarParserRULE_term_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&13) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactor_operatorContext is an interface to support dynamic dispatch.
type IFactor_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsFactor_operatorContext differentiates from other interfaces.
	IsFactor_operatorContext()
}

type Factor_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactor_operatorContext() *Factor_operatorContext {
	var p = new(Factor_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_factor_operator
	return p
}

func InitEmptyFactor_operatorContext(p *Factor_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_factor_operator
}

func (*Factor_operatorContext) IsFactor_operatorContext() {}

func NewFactor_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Factor_operatorContext {
	var p = new(Factor_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_factor_operator

	return p
}

func (s *Factor_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Factor_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(FlexarParserPLUS, 0)
}

func (s *Factor_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(FlexarParserMINUS, 0)
}

func (s *Factor_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Factor_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Factor_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFactor_operator(s)
	}
}

func (s *Factor_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFactor_operator(s)
	}
}

func (s *Factor_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFactor_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Factor_operator() (localctx IFactor_operatorContext) {
	localctx = NewFactor_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, FlexarParserRULE_factor_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlexarParserPLUS || _la == FlexarParserMINUS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparision_operatorContext is an interface to support dynamic dispatch.
type IComparision_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL() antlr.TerminalNode
	NOT_EQUAL() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LESS_EQUAL() antlr.TerminalNode
	GREATER() antlr.TerminalNode
	GREATER_EQUAL() antlr.TerminalNode

	// IsComparision_operatorContext differentiates from other interfaces.
	IsComparision_operatorContext()
}

type Comparision_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparision_operatorContext() *Comparision_operatorContext {
	var p = new(Comparision_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_comparision_operator
	return p
}

func InitEmptyComparision_operatorContext(p *Comparision_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_comparision_operator
}

func (*Comparision_operatorContext) IsComparision_operatorContext() {}

func NewComparision_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Comparision_operatorContext {
	var p = new(Comparision_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_comparision_operator

	return p
}

func (s *Comparision_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Comparision_operatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(FlexarParserEQUAL, 0)
}

func (s *Comparision_operatorContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(FlexarParserNOT_EQUAL, 0)
}

func (s *Comparision_operatorContext) LESS() antlr.TerminalNode {
	return s.GetToken(FlexarParserLESS, 0)
}

func (s *Comparision_operatorContext) LESS_EQUAL() antlr.TerminalNode {
	return s.GetToken(FlexarParserLESS_EQUAL, 0)
}

func (s *Comparision_operatorContext) GREATER() antlr.TerminalNode {
	return s.GetToken(FlexarParserGREATER, 0)
}

func (s *Comparision_operatorContext) GREATER_EQUAL() antlr.TerminalNode {
	return s.GetToken(FlexarParserGREATER_EQUAL, 0)
}

func (s *Comparision_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Comparision_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Comparision_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterComparision_operator(s)
	}
}

func (s *Comparision_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitComparision_operator(s)
	}
}

func (s *Comparision_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitComparision_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Comparision_operator() (localctx IComparision_operatorContext) {
	localctx = NewComparision_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, FlexarParserRULE_comparision_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-94)) & ^0x3f) == 0 && ((int64(1)<<(_la-94))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	INT_NUM() antlr.TerminalNode
	FLOAT_NUM() antlr.TerminalNode
	DEFAULT_STRING() antlr.TerminalNode
	TEMPLATE_STRING() antlr.TerminalNode

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_value
	return p
}

func InitEmptyValueContext(p *ValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_value
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(FlexarParserBOOLEAN, 0)
}

func (s *ValueContext) INT_NUM() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT_NUM, 0)
}

func (s *ValueContext) FLOAT_NUM() antlr.TerminalNode {
	return s.GetToken(FlexarParserFLOAT_NUM, 0)
}

func (s *ValueContext) DEFAULT_STRING() antlr.TerminalNode {
	return s.GetToken(FlexarParserDEFAULT_STRING, 0)
}

func (s *ValueContext) TEMPLATE_STRING() antlr.TerminalNode {
	return s.GetToken(FlexarParserTEMPLATE_STRING, 0)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitValue(s)
	}
}

func (s *ValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, FlexarParserRULE_value)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlexarParserBOOLEAN || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&216172782113783811) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable_declaration() IVariable_declarationContext
	Variable_assign() IVariable_assignContext
	Expression() IExpressionContext
	For_statement() IFor_statementContext
	If_statement() IIf_statementContext
	While_statement() IWhile_statementContext
	Do_while_statement() IDo_while_statementContext
	Switch_statement() ISwitch_statementContext
	Try_statement() ITry_statementContext
	New_scope() INew_scopeContext
	BREAK() antlr.TerminalNode
	CONTINUE() antlr.TerminalNode

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Variable_declaration() IVariable_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *StatementContext) Variable_assign() IVariable_assignContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_assignContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_assignContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) For_statement() IFor_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_statementContext)
}

func (s *StatementContext) If_statement() IIf_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *StatementContext) While_statement() IWhile_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_statementContext)
}

func (s *StatementContext) Do_while_statement() IDo_while_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDo_while_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDo_while_statementContext)
}

func (s *StatementContext) Switch_statement() ISwitch_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitch_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitch_statementContext)
}

func (s *StatementContext) Try_statement() ITry_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITry_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITry_statementContext)
}

func (s *StatementContext) New_scope() INew_scopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INew_scopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INew_scopeContext)
}

func (s *StatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(FlexarParserBREAK, 0)
}

func (s *StatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCONTINUE, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, FlexarParserRULE_statement)
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(746)
			p.Variable_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Variable_assign()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(748)
			p.expression(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(749)
			p.For_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(750)
			p.If_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(751)
			p.While_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(752)
			p.Do_while_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(753)
			p.Switch_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(754)
			p.Try_statement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(755)
			p.New_scope()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(756)
			p.Match(FlexarParserBREAK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(757)
			p.Match(FlexarParserCONTINUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INew_scopeContext is an interface to support dynamic dispatch.
type INew_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsNew_scopeContext differentiates from other interfaces.
	IsNew_scopeContext()
}

type New_scopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_scopeContext() *New_scopeContext {
	var p = new(New_scopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_new_scope
	return p
}

func InitEmptyNew_scopeContext(p *New_scopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_new_scope
}

func (*New_scopeContext) IsNew_scopeContext() {}

func NewNew_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_scopeContext {
	var p = new(New_scopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_new_scope

	return p
}

func (s *New_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *New_scopeContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *New_scopeContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *New_scopeContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *New_scopeContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *New_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterNew_scope(s)
	}
}

func (s *New_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitNew_scope(s)
	}
}

func (s *New_scopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitNew_scope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) New_scope() (localctx INew_scopeContext) {
	localctx = NewNew_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, FlexarParserRULE_new_scope)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(760)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(761)
			p.Statement()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_statementContext is an interface to support dynamic dispatch.
type IFor_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	For_rule() IFor_ruleContext
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsFor_statementContext differentiates from other interfaces.
	IsFor_statementContext()
}

type For_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_statementContext() *For_statementContext {
	var p = new(For_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_for_statement
	return p
}

func InitEmptyFor_statementContext(p *For_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_for_statement
}

func (*For_statementContext) IsFor_statementContext() {}

func NewFor_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_statementContext {
	var p = new(For_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_for_statement

	return p
}

func (s *For_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(FlexarParserFOR, 0)
}

func (s *For_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *For_statementContext) For_rule() IFor_ruleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_ruleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_ruleContext)
}

func (s *For_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *For_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *For_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *For_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *For_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *For_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFor_statement(s)
	}
}

func (s *For_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFor_statement(s)
	}
}

func (s *For_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFor_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) For_statement() (localctx IFor_statementContext) {
	localctx = NewFor_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, FlexarParserRULE_for_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(FlexarParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(771)
		p.For_rule()
	}
	{
		p.SetState(772)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(774)
			p.Statement()
		}

		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(780)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_ruleContext is an interface to support dynamic dispatch.
type IFor_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	For_in() IFor_inContext
	Full_for() IFull_forContext

	// IsFor_ruleContext differentiates from other interfaces.
	IsFor_ruleContext()
}

type For_ruleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_ruleContext() *For_ruleContext {
	var p = new(For_ruleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_for_rule
	return p
}

func InitEmptyFor_ruleContext(p *For_ruleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_for_rule
}

func (*For_ruleContext) IsFor_ruleContext() {}

func NewFor_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_ruleContext {
	var p = new(For_ruleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_for_rule

	return p
}

func (s *For_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *For_ruleContext) For_in() IFor_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_inContext)
}

func (s *For_ruleContext) Full_for() IFull_forContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFull_forContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFull_forContext)
}

func (s *For_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFor_rule(s)
	}
}

func (s *For_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFor_rule(s)
	}
}

func (s *For_ruleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFor_rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) For_rule() (localctx IFor_ruleContext) {
	localctx = NewFor_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, FlexarParserRULE_for_rule)
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(782)
			p.For_in()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(783)
			p.Full_for()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_inContext is an interface to support dynamic dispatch.
type IFor_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext
	AllDISCARD() []antlr.TerminalNode
	DISCARD(i int) antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode

	// IsFor_inContext differentiates from other interfaces.
	IsFor_inContext()
}

type For_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_inContext() *For_inContext {
	var p = new(For_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_for_in
	return p
}

func InitEmptyFor_inContext(p *For_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_for_in
}

func (*For_inContext) IsFor_inContext() {}

func NewFor_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_inContext {
	var p = new(For_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_for_in

	return p
}

func (s *For_inContext) GetParser() antlr.Parser { return s.parser }

func (s *For_inContext) COMMA() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, 0)
}

func (s *For_inContext) IN() antlr.TerminalNode {
	return s.GetToken(FlexarParserIN, 0)
}

func (s *For_inContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_inContext) AllDISCARD() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserDISCARD)
}

func (s *For_inContext) DISCARD(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserDISCARD, i)
}

func (s *For_inContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *For_inContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *For_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFor_in(s)
	}
}

func (s *For_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFor_in(s)
	}
}

func (s *For_inContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFor_in(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) For_in() (localctx IFor_inContext) {
	localctx = NewFor_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, FlexarParserRULE_for_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlexarParserDISCARD || _la == FlexarParserNAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(787)
		p.Match(FlexarParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(788)
		_la = p.GetTokenStream().LA(1)

		if !(_la == FlexarParserDISCARD || _la == FlexarParserNAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(789)
		p.Match(FlexarParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(790)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFull_forContext is an interface to support dynamic dispatch.
type IFull_forContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable_declaration() IVariable_declarationContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsFull_forContext differentiates from other interfaces.
	IsFull_forContext()
}

type Full_forContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFull_forContext() *Full_forContext {
	var p = new(Full_forContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_full_for
	return p
}

func InitEmptyFull_forContext(p *Full_forContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_full_for
}

func (*Full_forContext) IsFull_forContext() {}

func NewFull_forContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Full_forContext {
	var p = new(Full_forContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_full_for

	return p
}

func (s *Full_forContext) GetParser() antlr.Parser { return s.parser }

func (s *Full_forContext) Variable_declaration() IVariable_declarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_declarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_declarationContext)
}

func (s *Full_forContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserSEMICOLON)
}

func (s *Full_forContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserSEMICOLON, i)
}

func (s *Full_forContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Full_forContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Full_forContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Full_forContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Full_forContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFull_for(s)
	}
}

func (s *Full_forContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFull_for(s)
	}
}

func (s *Full_forContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFull_for(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Full_for() (localctx IFull_forContext) {
	localctx = NewFull_forContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, FlexarParserRULE_full_for)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Variable_declaration()
	}
	{
		p.SetState(793)
		p.Match(FlexarParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(794)
			p.expression(0)
		}

	}
	{
		p.SetState(797)
		p.Match(FlexarParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(798)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhile_statementContext is an interface to support dynamic dispatch.
type IWhile_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsWhile_statementContext differentiates from other interfaces.
	IsWhile_statementContext()
}

type While_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_statementContext() *While_statementContext {
	var p = new(While_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_while_statement
	return p
}

func InitEmptyWhile_statementContext(p *While_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_while_statement
}

func (*While_statementContext) IsWhile_statementContext() {}

func NewWhile_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_statementContext {
	var p = new(While_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_while_statement

	return p
}

func (s *While_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *While_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(FlexarParserWHILE, 0)
}

func (s *While_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *While_statementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *While_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *While_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *While_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *While_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *While_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *While_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterWhile_statement(s)
	}
}

func (s *While_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitWhile_statement(s)
	}
}

func (s *While_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitWhile_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) While_statement() (localctx IWhile_statementContext) {
	localctx = NewWhile_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, FlexarParserRULE_while_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.Match(FlexarParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(802)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(803)
		p.expression(0)
	}
	{
		p.SetState(804)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(805)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(806)
			p.Statement()
		}

		p.SetState(811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(812)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDo_while_statementContext is an interface to support dynamic dispatch.
type IDo_while_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	WHILE() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	CLOSE_PAREN() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsDo_while_statementContext differentiates from other interfaces.
	IsDo_while_statementContext()
}

type Do_while_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_while_statementContext() *Do_while_statementContext {
	var p = new(Do_while_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_do_while_statement
	return p
}

func InitEmptyDo_while_statementContext(p *Do_while_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_do_while_statement
}

func (*Do_while_statementContext) IsDo_while_statementContext() {}

func NewDo_while_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_while_statementContext {
	var p = new(Do_while_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_do_while_statement

	return p
}

func (s *Do_while_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_while_statementContext) DO() antlr.TerminalNode {
	return s.GetToken(FlexarParserDO, 0)
}

func (s *Do_while_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Do_while_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Do_while_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(FlexarParserWHILE, 0)
}

func (s *Do_while_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Do_while_statementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Do_while_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Do_while_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Do_while_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Do_while_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_while_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Do_while_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterDo_while_statement(s)
	}
}

func (s *Do_while_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitDo_while_statement(s)
	}
}

func (s *Do_while_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitDo_while_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Do_while_statement() (localctx IDo_while_statementContext) {
	localctx = NewDo_while_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, FlexarParserRULE_do_while_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.Match(FlexarParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(815)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(816)
			p.Statement()
		}

		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(822)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(823)
		p.Match(FlexarParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(824)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(825)
		p.expression(0)
	}
	{
		p.SetState(826)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitch_statementContext is an interface to support dynamic dispatch.
type ISwitch_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllSwitch_case() []ISwitch_caseContext
	Switch_case(i int) ISwitch_caseContext

	// IsSwitch_statementContext differentiates from other interfaces.
	IsSwitch_statementContext()
}

type Switch_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_statementContext() *Switch_statementContext {
	var p = new(Switch_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_switch_statement
	return p
}

func InitEmptySwitch_statementContext(p *Switch_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_switch_statement
}

func (*Switch_statementContext) IsSwitch_statementContext() {}

func NewSwitch_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_statementContext {
	var p = new(Switch_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_switch_statement

	return p
}

func (s *Switch_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_statementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(FlexarParserSWITCH, 0)
}

func (s *Switch_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Switch_statementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Switch_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Switch_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Switch_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Switch_statementContext) AllSwitch_case() []ISwitch_caseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitch_caseContext); ok {
			len++
		}
	}

	tst := make([]ISwitch_caseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitch_caseContext); ok {
			tst[i] = t.(ISwitch_caseContext)
			i++
		}
	}

	return tst
}

func (s *Switch_statementContext) Switch_case(i int) ISwitch_caseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitch_caseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitch_caseContext)
}

func (s *Switch_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterSwitch_statement(s)
	}
}

func (s *Switch_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitSwitch_statement(s)
	}
}

func (s *Switch_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitSwitch_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Switch_statement() (localctx ISwitch_statementContext) {
	localctx = NewSwitch_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, FlexarParserRULE_switch_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(FlexarParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(829)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(830)
		p.expression(0)
	}
	{
		p.SetState(831)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(832)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserCASE || _la == FlexarParserDEFAULT {
		{
			p.SetState(833)
			p.Switch_case()
		}

		p.SetState(838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(839)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitch_caseContext is an interface to support dynamic dispatch.
type ISwitch_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	Expression() IExpressionContext
	COLON() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	DEFAULT() antlr.TerminalNode

	// IsSwitch_caseContext differentiates from other interfaces.
	IsSwitch_caseContext()
}

type Switch_caseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_caseContext() *Switch_caseContext {
	var p = new(Switch_caseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_switch_case
	return p
}

func InitEmptySwitch_caseContext(p *Switch_caseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_switch_case
}

func (*Switch_caseContext) IsSwitch_caseContext() {}

func NewSwitch_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_caseContext {
	var p = new(Switch_caseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_switch_case

	return p
}

func (s *Switch_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_caseContext) CASE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCASE, 0)
}

func (s *Switch_caseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Switch_caseContext) COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, 0)
}

func (s *Switch_caseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Switch_caseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Switch_caseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(FlexarParserDEFAULT, 0)
}

func (s *Switch_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterSwitch_case(s)
	}
}

func (s *Switch_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitSwitch_case(s)
	}
}

func (s *Switch_caseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitSwitch_case(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Switch_case() (localctx ISwitch_caseContext) {
	localctx = NewSwitch_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, FlexarParserRULE_switch_case)
	var _la int

	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.Match(FlexarParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(842)
			p.expression(0)
		}
		{
			p.SetState(843)
			p.Match(FlexarParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
			{
				p.SetState(844)
				p.Statement()
			}

			p.SetState(849)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case FlexarParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(850)
			p.Match(FlexarParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(851)
			p.Match(FlexarParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
			{
				p.SetState(852)
				p.Statement()
			}

			p.SetState(857)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITry_statementContext is an interface to support dynamic dispatch.
type ITry_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Catch_statement() ICatch_statementContext
	Finally_statement() IFinally_statementContext

	// IsTry_statementContext differentiates from other interfaces.
	IsTry_statementContext()
}

type Try_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_statementContext() *Try_statementContext {
	var p = new(Try_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_try_statement
	return p
}

func InitEmptyTry_statementContext(p *Try_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_try_statement
}

func (*Try_statementContext) IsTry_statementContext() {}

func NewTry_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_statementContext {
	var p = new(Try_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_try_statement

	return p
}

func (s *Try_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_statementContext) TRY() antlr.TerminalNode {
	return s.GetToken(FlexarParserTRY, 0)
}

func (s *Try_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Try_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Try_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Try_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Try_statementContext) Catch_statement() ICatch_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatch_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatch_statementContext)
}

func (s *Try_statementContext) Finally_statement() IFinally_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinally_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinally_statementContext)
}

func (s *Try_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterTry_statement(s)
	}
}

func (s *Try_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitTry_statement(s)
	}
}

func (s *Try_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitTry_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Try_statement() (localctx ITry_statementContext) {
	localctx = NewTry_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, FlexarParserRULE_try_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(FlexarParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(861)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(862)
			p.Statement()
		}

		p.SetState(867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(868)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserCATCH {
		{
			p.SetState(869)
			p.Catch_statement()
		}

	}
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserFINALLY {
		{
			p.SetState(872)
			p.Finally_statement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatch_statementContext is an interface to support dynamic dispatch.
type ICatch_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsCatch_statementContext differentiates from other interfaces.
	IsCatch_statementContext()
}

type Catch_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatch_statementContext() *Catch_statementContext {
	var p = new(Catch_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_catch_statement
	return p
}

func InitEmptyCatch_statementContext(p *Catch_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_catch_statement
}

func (*Catch_statementContext) IsCatch_statementContext() {}

func NewCatch_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Catch_statementContext {
	var p = new(Catch_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_catch_statement

	return p
}

func (s *Catch_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Catch_statementContext) CATCH() antlr.TerminalNode {
	return s.GetToken(FlexarParserCATCH, 0)
}

func (s *Catch_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Catch_statementContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Catch_statementContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Catch_statementContext) COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, 0)
}

func (s *Catch_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Catch_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Catch_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Catch_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Catch_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Catch_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Catch_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Catch_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterCatch_statement(s)
	}
}

func (s *Catch_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitCatch_statement(s)
	}
}

func (s *Catch_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitCatch_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Catch_statement() (localctx ICatch_statementContext) {
	localctx = NewCatch_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, FlexarParserRULE_catch_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(FlexarParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(876)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(877)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(878)
		p.Match(FlexarParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(879)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(880)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(881)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(882)
			p.Statement()
		}

		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(888)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinally_statementContext is an interface to support dynamic dispatch.
type IFinally_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsFinally_statementContext differentiates from other interfaces.
	IsFinally_statementContext()
}

type Finally_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinally_statementContext() *Finally_statementContext {
	var p = new(Finally_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_finally_statement
	return p
}

func InitEmptyFinally_statementContext(p *Finally_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_finally_statement
}

func (*Finally_statementContext) IsFinally_statementContext() {}

func NewFinally_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finally_statementContext {
	var p = new(Finally_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_finally_statement

	return p
}

func (s *Finally_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Finally_statementContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(FlexarParserFINALLY, 0)
}

func (s *Finally_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Finally_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Finally_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Finally_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Finally_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finally_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finally_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFinally_statement(s)
	}
}

func (s *Finally_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFinally_statement(s)
	}
}

func (s *Finally_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFinally_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Finally_statement() (localctx IFinally_statementContext) {
	localctx = NewFinally_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, FlexarParserRULE_finally_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(FlexarParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(891)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(892)
			p.Statement()
		}

		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(898)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllElif_statement() []IElif_statementContext
	Elif_statement(i int) IElif_statementContext
	Else_statement() IElse_statementContext

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_if_statement
	return p
}

func InitEmptyIf_statementContext(p *If_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_if_statement
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(FlexarParserIF, 0)
}

func (s *If_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *If_statementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *If_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *If_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *If_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *If_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *If_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *If_statementContext) AllElif_statement() []IElif_statementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElif_statementContext); ok {
			len++
		}
	}

	tst := make([]IElif_statementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElif_statementContext); ok {
			tst[i] = t.(IElif_statementContext)
			i++
		}
	}

	return tst
}

func (s *If_statementContext) Elif_statement(i int) IElif_statementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElif_statementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElif_statementContext)
}

func (s *If_statementContext) Else_statement() IElse_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_statementContext)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (s *If_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitIf_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) If_statement() (localctx IIf_statementContext) {
	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, FlexarParserRULE_if_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(900)
		p.Match(FlexarParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(901)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(902)
		p.expression(0)
	}
	{
		p.SetState(903)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(904)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(905)
			p.Statement()
		}

		p.SetState(910)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(911)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserELIF {
		{
			p.SetState(912)
			p.Elif_statement()
		}

		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserELSE {
		{
			p.SetState(918)
			p.Else_statement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElif_statementContext is an interface to support dynamic dispatch.
type IElif_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELIF() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	Expression() IExpressionContext
	CLOSE_PAREN() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsElif_statementContext differentiates from other interfaces.
	IsElif_statementContext()
}

type Elif_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElif_statementContext() *Elif_statementContext {
	var p = new(Elif_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_elif_statement
	return p
}

func InitEmptyElif_statementContext(p *Elif_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_elif_statement
}

func (*Elif_statementContext) IsElif_statementContext() {}

func NewElif_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elif_statementContext {
	var p = new(Elif_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_elif_statement

	return p
}

func (s *Elif_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Elif_statementContext) ELIF() antlr.TerminalNode {
	return s.GetToken(FlexarParserELIF, 0)
}

func (s *Elif_statementContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Elif_statementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Elif_statementContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Elif_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Elif_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Elif_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Elif_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Elif_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elif_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elif_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterElif_statement(s)
	}
}

func (s *Elif_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitElif_statement(s)
	}
}

func (s *Elif_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitElif_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Elif_statement() (localctx IElif_statementContext) {
	localctx = NewElif_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, FlexarParserRULE_elif_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(921)
		p.Match(FlexarParserELIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(922)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(923)
		p.expression(0)
	}
	{
		p.SetState(924)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(925)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(926)
			p.Statement()
		}

		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(932)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElse_statementContext is an interface to support dynamic dispatch.
type IElse_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsElse_statementContext differentiates from other interfaces.
	IsElse_statementContext()
}

type Else_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_statementContext() *Else_statementContext {
	var p = new(Else_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_else_statement
	return p
}

func InitEmptyElse_statementContext(p *Else_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_else_statement
}

func (*Else_statementContext) IsElse_statementContext() {}

func NewElse_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_statementContext {
	var p = new(Else_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_else_statement

	return p
}

func (s *Else_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(FlexarParserELSE, 0)
}

func (s *Else_statementContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Else_statementContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Else_statementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Else_statementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Else_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterElse_statement(s)
	}
}

func (s *Else_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitElse_statement(s)
	}
}

func (s *Else_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitElse_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Else_statement() (localctx IElse_statementContext) {
	localctx = NewElse_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, FlexarParserRULE_else_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.Match(FlexarParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(935)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(936)
			p.Statement()
		}

		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(942)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStruct_funcContext is an interface to support dynamic dispatch.
type IStruct_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAREN() antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_() IFuncContext
	STAR() antlr.TerminalNode

	// IsStruct_funcContext differentiates from other interfaces.
	IsStruct_funcContext()
}

type Struct_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_funcContext() *Struct_funcContext {
	var p = new(Struct_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct_func
	return p
}

func InitEmptyStruct_funcContext(p *Struct_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_struct_func
}

func (*Struct_funcContext) IsStruct_funcContext() {}

func NewStruct_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_funcContext {
	var p = new(Struct_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_struct_func

	return p
}

func (s *Struct_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_funcContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Struct_funcContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *Struct_funcContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *Struct_funcContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Struct_funcContext) Func_() IFuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncContext)
}

func (s *Struct_funcContext) STAR() antlr.TerminalNode {
	return s.GetToken(FlexarParserSTAR, 0)
}

func (s *Struct_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterStruct_func(s)
	}
}

func (s *Struct_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitStruct_func(s)
	}
}

func (s *Struct_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitStruct_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Struct_func() (localctx IStruct_funcContext) {
	localctx = NewStruct_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, FlexarParserRULE_struct_func)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(945)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserSTAR {
		{
			p.SetState(946)
			p.Match(FlexarParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(949)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(950)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(951)
		p.Func_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncContext is an interface to support dynamic dispatch.
type IFuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	NAME() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_body() IFunc_bodyContext
	Func_param() IFunc_paramContext
	Func_return() IFunc_returnContext

	// IsFuncContext differentiates from other interfaces.
	IsFuncContext()
}

type FuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncContext() *FuncContext {
	var p = new(FuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func
	return p
}

func InitEmptyFuncContext(p *FuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func
}

func (*FuncContext) IsFuncContext() {}

func NewFuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncContext {
	var p = new(FuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func

	return p
}

func (s *FuncContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncContext) FUNC() antlr.TerminalNode {
	return s.GetToken(FlexarParserFUNC, 0)
}

func (s *FuncContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *FuncContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *FuncContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *FuncContext) Func_body() IFunc_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_bodyContext)
}

func (s *FuncContext) Func_param() IFunc_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *FuncContext) Func_return() IFunc_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_returnContext)
}

func (s *FuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc(s)
	}
}

func (s *FuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc(s)
	}
}

func (s *FuncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_() (localctx IFuncContext) {
	localctx = NewFuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, FlexarParserRULE_func)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)
		p.Match(FlexarParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(954)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(955)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserNAME {
		{
			p.SetState(956)
			p.Func_param()
		}

	}
	{
		p.SetState(959)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770688) != 0) || _la == FlexarParserNAME || _la == FlexarParserOPEN_PAREN {
		{
			p.SetState(960)
			p.Func_return()
		}

	}
	{
		p.SetState(963)
		p.Func_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymous_funcContext is an interface to support dynamic dispatch.
type IAnonymous_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	Func_body() IFunc_bodyContext
	Func_param() IFunc_paramContext
	Func_return() IFunc_returnContext

	// IsAnonymous_funcContext differentiates from other interfaces.
	IsAnonymous_funcContext()
}

type Anonymous_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymous_funcContext() *Anonymous_funcContext {
	var p = new(Anonymous_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_anonymous_func
	return p
}

func InitEmptyAnonymous_funcContext(p *Anonymous_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_anonymous_func
}

func (*Anonymous_funcContext) IsAnonymous_funcContext() {}

func NewAnonymous_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Anonymous_funcContext {
	var p = new(Anonymous_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_anonymous_func

	return p
}

func (s *Anonymous_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Anonymous_funcContext) FUNC() antlr.TerminalNode {
	return s.GetToken(FlexarParserFUNC, 0)
}

func (s *Anonymous_funcContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Anonymous_funcContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Anonymous_funcContext) ARROW() antlr.TerminalNode {
	return s.GetToken(FlexarParserARROW, 0)
}

func (s *Anonymous_funcContext) Func_body() IFunc_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_bodyContext)
}

func (s *Anonymous_funcContext) Func_param() IFunc_paramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *Anonymous_funcContext) Func_return() IFunc_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_returnContext)
}

func (s *Anonymous_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anonymous_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Anonymous_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterAnonymous_func(s)
	}
}

func (s *Anonymous_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitAnonymous_func(s)
	}
}

func (s *Anonymous_funcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitAnonymous_func(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Anonymous_func() (localctx IAnonymous_funcContext) {
	localctx = NewAnonymous_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, FlexarParserRULE_anonymous_func)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(965)
		p.Match(FlexarParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(966)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserNAME {
		{
			p.SetState(967)
			p.Func_param()
		}

	}
	{
		p.SetState(970)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770688) != 0) || _la == FlexarParserNAME || _la == FlexarParserOPEN_PAREN {
		{
			p.SetState(971)
			p.Func_return()
		}

	}
	{
		p.SetState(974)
		p.Match(FlexarParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		p.Func_body()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_paramContext is an interface to support dynamic dispatch.
type IFunc_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunc_param_rule() []IFunc_param_ruleContext
	Func_param_rule(i int) IFunc_param_ruleContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunc_paramContext differentiates from other interfaces.
	IsFunc_paramContext()
}

type Func_paramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_paramContext() *Func_paramContext {
	var p = new(Func_paramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_param
	return p
}

func InitEmptyFunc_paramContext(p *Func_paramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_param
}

func (*Func_paramContext) IsFunc_paramContext() {}

func NewFunc_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_paramContext {
	var p = new(Func_paramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_param

	return p
}

func (s *Func_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_paramContext) AllFunc_param_rule() []IFunc_param_ruleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunc_param_ruleContext); ok {
			len++
		}
	}

	tst := make([]IFunc_param_ruleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunc_param_ruleContext); ok {
			tst[i] = t.(IFunc_param_ruleContext)
			i++
		}
	}

	return tst
}

func (s *Func_paramContext) Func_param_rule(i int) IFunc_param_ruleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_param_ruleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_param_ruleContext)
}

func (s *Func_paramContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Func_paramContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Func_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_param(s)
	}
}

func (s *Func_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_param(s)
	}
}

func (s *Func_paramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_param(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_param() (localctx IFunc_paramContext) {
	localctx = NewFunc_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, FlexarParserRULE_func_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.Func_param_rule()
	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserCOMMA {
		{
			p.SetState(978)
			p.Match(FlexarParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(979)
			p.Func_param_rule()
		}

		p.SetState(984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_callbackContext is an interface to support dynamic dispatch.
type IFunc_callbackContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNC() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_param_callback() IFunc_param_callbackContext
	Func_return() IFunc_returnContext

	// IsFunc_callbackContext differentiates from other interfaces.
	IsFunc_callbackContext()
}

type Func_callbackContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_callbackContext() *Func_callbackContext {
	var p = new(Func_callbackContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_callback
	return p
}

func InitEmptyFunc_callbackContext(p *Func_callbackContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_callback
}

func (*Func_callbackContext) IsFunc_callbackContext() {}

func NewFunc_callbackContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_callbackContext {
	var p = new(Func_callbackContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_callback

	return p
}

func (s *Func_callbackContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_callbackContext) FUNC() antlr.TerminalNode {
	return s.GetToken(FlexarParserFUNC, 0)
}

func (s *Func_callbackContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Func_callbackContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Func_callbackContext) Func_param_callback() IFunc_param_callbackContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_param_callbackContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_param_callbackContext)
}

func (s *Func_callbackContext) Func_return() IFunc_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_returnContext)
}

func (s *Func_callbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_callbackContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_callbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_callback(s)
	}
}

func (s *Func_callbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_callback(s)
	}
}

func (s *Func_callbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_callback(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_callback() (localctx IFunc_callbackContext) {
	localctx = NewFunc_callbackContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, FlexarParserRULE_func_callback)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(985)
		p.Match(FlexarParserFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(986)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-11)) & ^0x3f) == 0 && ((int64(1)<<(_la-11))&153122385199890433) != 0 {
		{
			p.SetState(987)
			p.Func_param_callback()
		}

	}
	{
		p.SetState(990)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(992)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(991)
			p.Func_return()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_param_callbackContext is an interface to support dynamic dispatch.
type IFunc_param_callbackContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunc_param_callbackContext differentiates from other interfaces.
	IsFunc_param_callbackContext()
}

type Func_param_callbackContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_param_callbackContext() *Func_param_callbackContext {
	var p = new(Func_param_callbackContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_param_callback
	return p
}

func InitEmptyFunc_param_callbackContext(p *Func_param_callbackContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_param_callback
}

func (*Func_param_callbackContext) IsFunc_param_callbackContext() {}

func NewFunc_param_callbackContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_param_callbackContext {
	var p = new(Func_param_callbackContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_param_callback

	return p
}

func (s *Func_param_callbackContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_param_callbackContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Func_param_callbackContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Func_param_callbackContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Func_param_callbackContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Func_param_callbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_param_callbackContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_param_callbackContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_param_callback(s)
	}
}

func (s *Func_param_callbackContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_param_callback(s)
	}
}

func (s *Func_param_callbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_param_callback(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_param_callback() (localctx IFunc_param_callbackContext) {
	localctx = NewFunc_param_callbackContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, FlexarParserRULE_func_param_callback)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(994)
		p.Type_()
	}
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserCOMMA {
		{
			p.SetState(995)
			p.Match(FlexarParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(996)
			p.Type_()
		}

		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_param_ruleContext is an interface to support dynamic dispatch.
type IFunc_param_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	QUESTION() antlr.TerminalNode
	SPREAD() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Value() IValueContext

	// IsFunc_param_ruleContext differentiates from other interfaces.
	IsFunc_param_ruleContext()
}

type Func_param_ruleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_param_ruleContext() *Func_param_ruleContext {
	var p = new(Func_param_ruleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_param_rule
	return p
}

func InitEmptyFunc_param_ruleContext(p *Func_param_ruleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_param_rule
}

func (*Func_param_ruleContext) IsFunc_param_ruleContext() {}

func NewFunc_param_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_param_ruleContext {
	var p = new(Func_param_ruleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_param_rule

	return p
}

func (s *Func_param_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_param_ruleContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Func_param_ruleContext) COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, 0)
}

func (s *Func_param_ruleContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Func_param_ruleContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(FlexarParserQUESTION, 0)
}

func (s *Func_param_ruleContext) SPREAD() antlr.TerminalNode {
	return s.GetToken(FlexarParserSPREAD, 0)
}

func (s *Func_param_ruleContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserASSIGN, 0)
}

func (s *Func_param_ruleContext) Value() IValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *Func_param_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_param_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_param_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_param_rule(s)
	}
}

func (s *Func_param_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_param_rule(s)
	}
}

func (s *Func_param_ruleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_param_rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_param_rule() (localctx IFunc_param_ruleContext) {
	localctx = NewFunc_param_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, FlexarParserRULE_func_param_rule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserQUESTION {
		{
			p.SetState(1003)
			p.Match(FlexarParserQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1006)
		p.Match(FlexarParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1007)
		p.Type_()
	}
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserSPREAD {
		{
			p.SetState(1008)
			p.Match(FlexarParserSPREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserASSIGN {
		{
			p.SetState(1011)
			p.Match(FlexarParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1012)
			p.Value()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_callContext is an interface to support dynamic dispatch.
type IFunc_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	Func_call_params() IFunc_call_paramsContext

	// IsFunc_callContext differentiates from other interfaces.
	IsFunc_callContext()
}

type Func_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_callContext() *Func_callContext {
	var p = new(Func_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_call
	return p
}

func InitEmptyFunc_callContext(p *Func_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_call
}

func (*Func_callContext) IsFunc_callContext() {}

func NewFunc_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_callContext {
	var p = new(Func_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_call

	return p
}

func (s *Func_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_callContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Func_callContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Func_callContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Func_callContext) Func_call_params() IFunc_call_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_call_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_call_paramsContext)
}

func (s *Func_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_call(s)
	}
}

func (s *Func_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_call(s)
	}
}

func (s *Func_callContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_call(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_call() (localctx IFunc_callContext) {
	localctx = NewFunc_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, FlexarParserRULE_func_call)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1016)
		p.Match(FlexarParserOPEN_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4363686770240) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(1017)
			p.Func_call_params()
		}

	}
	{
		p.SetState(1020)
		p.Match(FlexarParserCLOSE_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_call_paramsContext is an interface to support dynamic dispatch.
type IFunc_call_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunc_call_paramsContext differentiates from other interfaces.
	IsFunc_call_paramsContext()
}

type Func_call_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_call_paramsContext() *Func_call_paramsContext {
	var p = new(Func_call_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_call_params
	return p
}

func InitEmptyFunc_call_paramsContext(p *Func_call_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_call_params
}

func (*Func_call_paramsContext) IsFunc_call_paramsContext() {}

func NewFunc_call_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_call_paramsContext {
	var p = new(Func_call_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_call_params

	return p
}

func (s *Func_call_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_call_paramsContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Func_call_paramsContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Func_call_paramsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Func_call_paramsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Func_call_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_call_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_call_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_call_params(s)
	}
}

func (s *Func_call_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_call_params(s)
	}
}

func (s *Func_call_paramsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_call_params(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_call_params() (localctx IFunc_call_paramsContext) {
	localctx = NewFunc_call_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, FlexarParserRULE_func_call_params)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1022)
		p.expression(0)
	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserCOMMA {
		{
			p.SetState(1023)
			p.Match(FlexarParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1024)
			p.expression(0)
		}

		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_returnContext is an interface to support dynamic dispatch.
type IFunc_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	OPEN_PAREN() antlr.TerminalNode
	CLOSE_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunc_returnContext differentiates from other interfaces.
	IsFunc_returnContext()
}

type Func_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_returnContext() *Func_returnContext {
	var p = new(Func_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_return
	return p
}

func InitEmptyFunc_returnContext(p *Func_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_return
}

func (*Func_returnContext) IsFunc_returnContext() {}

func NewFunc_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_returnContext {
	var p = new(Func_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_return

	return p
}

func (s *Func_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_returnContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *Func_returnContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Func_returnContext) OPEN_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, 0)
}

func (s *Func_returnContext) CLOSE_PAREN() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, 0)
}

func (s *Func_returnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Func_returnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Func_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_return(s)
	}
}

func (s *Func_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_return(s)
	}
}

func (s *Func_returnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_return(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_return() (localctx IFunc_returnContext) {
	localctx = NewFunc_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, FlexarParserRULE_func_return)
	var _la int

	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserFUNC, FlexarParserCONST, FlexarParserINT, FlexarParserINT8, FlexarParserINT16, FlexarParserINT32, FlexarParserINT64, FlexarParserUINT, FlexarParserUINT8, FlexarParserUINT16, FlexarParserUINT32, FlexarParserUINT64, FlexarParserFLOAT, FlexarParserFLOAT32, FlexarParserFLOAT64, FlexarParserBOOL, FlexarParserCHAR, FlexarParserSTRING, FlexarParserINF, FlexarParserTUPLE, FlexarParserMAP, FlexarParserERROR, FlexarParserNULL, FlexarParserANY, FlexarParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1030)
			p.Type_()
		}

	case FlexarParserOPEN_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1031)
			p.Match(FlexarParserOPEN_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1032)
			p.Type_()
		}
		p.SetState(1037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == FlexarParserCOMMA {
			{
				p.SetState(1033)
				p.Match(FlexarParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1034)
				p.Type_()
			}

			p.SetState(1039)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1040)
			p.Match(FlexarParserCLOSE_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_bodyContext is an interface to support dynamic dispatch.
type IFunc_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_BRACE() antlr.TerminalNode
	CLOSE_BRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Return_statement() IReturn_statementContext

	// IsFunc_bodyContext differentiates from other interfaces.
	IsFunc_bodyContext()
}

type Func_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_bodyContext() *Func_bodyContext {
	var p = new(Func_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_body
	return p
}

func InitEmptyFunc_bodyContext(p *Func_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_func_body
}

func (*Func_bodyContext) IsFunc_bodyContext() {}

func NewFunc_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_bodyContext {
	var p = new(Func_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_func_body

	return p
}

func (s *Func_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_bodyContext) OPEN_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACE, 0)
}

func (s *Func_bodyContext) CLOSE_BRACE() antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACE, 0)
}

func (s *Func_bodyContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *Func_bodyContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Func_bodyContext) Return_statement() IReturn_statementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_statementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *Func_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFunc_body(s)
	}
}

func (s *Func_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFunc_body(s)
	}
}

func (s *Func_bodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFunc_body(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Func_body() (localctx IFunc_bodyContext) {
	localctx = NewFunc_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, FlexarParserRULE_func_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Match(FlexarParserOPEN_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-3797212460608) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&222932854479262735) != 0) {
		{
			p.SetState(1045)
			p.Statement()
		}

		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserRETURN {
		{
			p.SetState(1051)
			p.Return_statement()
		}

	}
	{
		p.SetState(1054)
		p.Match(FlexarParserCLOSE_BRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_return_statement
	return p
}

func InitEmptyReturn_statementContext(p *Return_statementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_return_statement
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(FlexarParserRETURN, 0)
}

func (s *Return_statementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *Return_statementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_statementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCOMMA)
}

func (s *Return_statementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCOMMA, i)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (s *Return_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitReturn_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Return_statement() (localctx IReturn_statementContext) {
	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, FlexarParserRULE_return_statement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Match(FlexarParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(1057)
		p.expression(0)
	}
	p.SetState(1062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == FlexarParserCOMMA {
		{
			p.SetState(1058)
			p.Match(FlexarParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1059)
			p.expression(0)
		}

		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_declarationContext is an interface to support dynamic dispatch.
type IVariable_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsVariable_declarationContext differentiates from other interfaces.
	IsVariable_declarationContext()
}

type Variable_declarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_declarationContext() *Variable_declarationContext {
	var p = new(Variable_declarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_variable_declaration
	return p
}

func InitEmptyVariable_declarationContext(p *Variable_declarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_variable_declaration
}

func (*Variable_declarationContext) IsVariable_declarationContext() {}

func NewVariable_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_declarationContext {
	var p = new(Variable_declarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_variable_declaration

	return p
}

func (s *Variable_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_declarationContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Variable_declarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(FlexarParserCOLON, 0)
}

func (s *Variable_declarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *Variable_declarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserASSIGN, 0)
}

func (s *Variable_declarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterVariable_declaration(s)
	}
}

func (s *Variable_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitVariable_declaration(s)
	}
}

func (s *Variable_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitVariable_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Variable_declaration() (localctx IVariable_declarationContext) {
	localctx = NewVariable_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, FlexarParserRULE_variable_declaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.Match(FlexarParserNAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(1066)
		p.Match(FlexarParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1067)
		p.Type_()
	}

	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == FlexarParserASSIGN {
		{
			p.SetState(1069)
			p.Match(FlexarParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1070)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_assignContext is an interface to support dynamic dispatch.
type IVariable_assignContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Variable_name() IVariable_nameContext
	Assing() IAssingContext
	Expression() IExpressionContext

	// IsVariable_assignContext differentiates from other interfaces.
	IsVariable_assignContext()
}

type Variable_assignContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_assignContext() *Variable_assignContext {
	var p = new(Variable_assignContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_variable_assign
	return p
}

func InitEmptyVariable_assignContext(p *Variable_assignContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_variable_assign
}

func (*Variable_assignContext) IsVariable_assignContext() {}

func NewVariable_assignContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_assignContext {
	var p = new(Variable_assignContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_variable_assign

	return p
}

func (s *Variable_assignContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_assignContext) Variable_name() IVariable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariable_nameContext)
}

func (s *Variable_assignContext) Assing() IAssingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssingContext)
}

func (s *Variable_assignContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Variable_assignContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_assignContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_assignContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterVariable_assign(s)
	}
}

func (s *Variable_assignContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitVariable_assign(s)
	}
}

func (s *Variable_assignContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitVariable_assign(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Variable_assign() (localctx IVariable_assignContext) {
	localctx = NewVariable_assignContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, FlexarParserRULE_variable_assign)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		p.Variable_name()
	}
	{
		p.SetState(1074)
		p.Assing()
	}
	{
		p.SetState(1075)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariable_nameContext is an interface to support dynamic dispatch.
type IVariable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME() antlr.TerminalNode
	THIS() antlr.TerminalNode
	DOT() antlr.TerminalNode
	DISCARD() antlr.TerminalNode

	// IsVariable_nameContext differentiates from other interfaces.
	IsVariable_nameContext()
}

type Variable_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_nameContext() *Variable_nameContext {
	var p = new(Variable_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_variable_name
	return p
}

func InitEmptyVariable_nameContext(p *Variable_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_variable_name
}

func (*Variable_nameContext) IsVariable_nameContext() {}

func NewVariable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_nameContext {
	var p = new(Variable_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_variable_name

	return p
}

func (s *Variable_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_nameContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Variable_nameContext) THIS() antlr.TerminalNode {
	return s.GetToken(FlexarParserTHIS, 0)
}

func (s *Variable_nameContext) DOT() antlr.TerminalNode {
	return s.GetToken(FlexarParserDOT, 0)
}

func (s *Variable_nameContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(FlexarParserDISCARD, 0)
}

func (s *Variable_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterVariable_name(s)
	}
}

func (s *Variable_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitVariable_name(s)
	}
}

func (s *Variable_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitVariable_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Variable_name() (localctx IVariable_nameContext) {
	localctx = NewVariable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, FlexarParserRULE_variable_name)
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserNAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1077)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlexarParserTHIS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.Match(FlexarParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.Match(FlexarParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1080)
			p.Match(FlexarParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case FlexarParserDISCARD:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1081)
			p.Match(FlexarParserDISCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssingContext is an interface to support dynamic dispatch.
type IAssingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASSIGN() antlr.TerminalNode
	PLUS_ASSIGN() antlr.TerminalNode
	MINUS_ASSIGN() antlr.TerminalNode
	STAR_ASSIGN() antlr.TerminalNode
	MODULE_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	EXP_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	OR_ASSIGN() antlr.TerminalNode
	XOR_ASSIGN() antlr.TerminalNode
	SHL_ASSIGN() antlr.TerminalNode
	SHR_ASSIGN() antlr.TerminalNode
	INF_ASSIGN() antlr.TerminalNode

	// IsAssingContext differentiates from other interfaces.
	IsAssingContext()
}

type AssingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssingContext() *AssingContext {
	var p = new(AssingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_assing
	return p
}

func InitEmptyAssingContext(p *AssingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_assing
}

func (*AssingContext) IsAssingContext() {}

func NewAssingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssingContext {
	var p = new(AssingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_assing

	return p
}

func (s *AssingContext) GetParser() antlr.Parser { return s.parser }

func (s *AssingContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserASSIGN, 0)
}

func (s *AssingContext) PLUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserPLUS_ASSIGN, 0)
}

func (s *AssingContext) MINUS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserMINUS_ASSIGN, 0)
}

func (s *AssingContext) STAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserSTAR_ASSIGN, 0)
}

func (s *AssingContext) MODULE_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserMODULE_ASSIGN, 0)
}

func (s *AssingContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserDIV_ASSIGN, 0)
}

func (s *AssingContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserEXP_ASSIGN, 0)
}

func (s *AssingContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserAND_ASSIGN, 0)
}

func (s *AssingContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserOR_ASSIGN, 0)
}

func (s *AssingContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserXOR_ASSIGN, 0)
}

func (s *AssingContext) SHL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserSHL_ASSIGN, 0)
}

func (s *AssingContext) SHR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserSHR_ASSIGN, 0)
}

func (s *AssingContext) INF_ASSIGN() antlr.TerminalNode {
	return s.GetToken(FlexarParserINF_ASSIGN, 0)
}

func (s *AssingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterAssing(s)
	}
}

func (s *AssingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitAssing(s)
	}
}

func (s *AssingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitAssing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Assing() (localctx IAssingContext) {
	localctx = NewAssingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, FlexarParserRULE_assing)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-81)) & ^0x3f) == 0 && ((int64(1)<<(_la-81))&8191) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFinal_type() []IFinal_typeContext
	Final_type(i int) IFinal_typeContext
	CONST() antlr.TerminalNode
	AllQUESTION() []antlr.TerminalNode
	QUESTION(i int) antlr.TerminalNode
	AllOPEN_BRACKET() []antlr.TerminalNode
	OPEN_BRACKET(i int) antlr.TerminalNode
	AllCLOSE_BRACKET() []antlr.TerminalNode
	CLOSE_BRACKET(i int) antlr.TerminalNode
	AllOPEN_PAREN() []antlr.TerminalNode
	OPEN_PAREN(i int) antlr.TerminalNode
	AllCLOSE_PAREN() []antlr.TerminalNode
	CLOSE_PAREN(i int) antlr.TerminalNode
	AllINT_NUM() []antlr.TerminalNode
	INT_NUM(i int) antlr.TerminalNode
	AllDYN() []antlr.TerminalNode
	DYN(i int) antlr.TerminalNode
	AllNAME() []antlr.TerminalNode
	NAME(i int) antlr.TerminalNode
	Func_callback() IFunc_callbackContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) AllFinal_type() []IFinal_typeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFinal_typeContext); ok {
			len++
		}
	}

	tst := make([]IFinal_typeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFinal_typeContext); ok {
			tst[i] = t.(IFinal_typeContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) Final_type(i int) IFinal_typeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinal_typeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinal_typeContext)
}

func (s *TypeContext) CONST() antlr.TerminalNode {
	return s.GetToken(FlexarParserCONST, 0)
}

func (s *TypeContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserQUESTION)
}

func (s *TypeContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserQUESTION, i)
}

func (s *TypeContext) AllOPEN_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserOPEN_BRACKET)
}

func (s *TypeContext) OPEN_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_BRACKET, i)
}

func (s *TypeContext) AllCLOSE_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCLOSE_BRACKET)
}

func (s *TypeContext) CLOSE_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_BRACKET, i)
}

func (s *TypeContext) AllOPEN_PAREN() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserOPEN_PAREN)
}

func (s *TypeContext) OPEN_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserOPEN_PAREN, i)
}

func (s *TypeContext) AllCLOSE_PAREN() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserCLOSE_PAREN)
}

func (s *TypeContext) CLOSE_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserCLOSE_PAREN, i)
}

func (s *TypeContext) AllINT_NUM() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserINT_NUM)
}

func (s *TypeContext) INT_NUM(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserINT_NUM, i)
}

func (s *TypeContext) AllDYN() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserDYN)
}

func (s *TypeContext) DYN(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserDYN, i)
}

func (s *TypeContext) AllNAME() []antlr.TerminalNode {
	return s.GetTokens(FlexarParserNAME)
}

func (s *TypeContext) NAME(i int) antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, i)
}

func (s *TypeContext) Func_callback() IFunc_callbackContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_callbackContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_callbackContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, FlexarParserRULE_type)
	var _la int

	var _alt int

	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case FlexarParserCONST, FlexarParserINT, FlexarParserINT8, FlexarParserINT16, FlexarParserINT32, FlexarParserINT64, FlexarParserUINT, FlexarParserUINT8, FlexarParserUINT16, FlexarParserUINT32, FlexarParserUINT64, FlexarParserFLOAT, FlexarParserFLOAT32, FlexarParserFLOAT64, FlexarParserBOOL, FlexarParserCHAR, FlexarParserSTRING, FlexarParserINF, FlexarParserTUPLE, FlexarParserMAP, FlexarParserERROR, FlexarParserNULL, FlexarParserANY, FlexarParserNAME:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == FlexarParserCONST {
			{
				p.SetState(1086)
				p.Match(FlexarParserCONST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1089)
			p.Final_type()
		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(1105)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1090)
						p.Match(FlexarParserQUESTION)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 2:
					{
						p.SetState(1091)
						p.Match(FlexarParserOPEN_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1093)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&144115188075855889) != 0 {
						{
							p.SetState(1092)
							_la = p.GetTokenStream().LA(1)

							if !((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&144115188075855889) != 0) {
								p.GetErrorHandler().RecoverInline(p)
							} else {
								p.GetErrorHandler().ReportMatch(p)
								p.Consume()
							}
						}

					}
					{
						p.SetState(1095)
						p.Match(FlexarParserCLOSE_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case 3:
					{
						p.SetState(1096)
						p.Match(FlexarParserOPEN_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1097)
						p.Final_type()
					}
					{
						p.SetState(1098)
						p.Match(FlexarParserOPEN_PAREN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(1100)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&144115188075855889) != 0 {
						{
							p.SetState(1099)
							_la = p.GetTokenStream().LA(1)

							if !((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&144115188075855889) != 0) {
								p.GetErrorHandler().RecoverInline(p)
							} else {
								p.GetErrorHandler().ReportMatch(p)
								p.Consume()
							}
						}

					}
					{
						p.SetState(1102)
						p.Match(FlexarParserCLOSE_PAREN)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1103)
						p.Match(FlexarParserCLOSE_BRACKET)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(1109)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case FlexarParserFUNC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1110)
			p.Func_callback()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinal_typeContext is an interface to support dynamic dispatch.
type IFinal_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT() antlr.TerminalNode
	INT8() antlr.TerminalNode
	INT16() antlr.TerminalNode
	INT32() antlr.TerminalNode
	INT64() antlr.TerminalNode
	UINT() antlr.TerminalNode
	UINT8() antlr.TerminalNode
	UINT16() antlr.TerminalNode
	UINT32() antlr.TerminalNode
	UINT64() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	FLOAT32() antlr.TerminalNode
	FLOAT64() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	STRING() antlr.TerminalNode
	INF() antlr.TerminalNode
	TUPLE() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ERROR() antlr.TerminalNode
	NULL() antlr.TerminalNode
	ANY() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsFinal_typeContext differentiates from other interfaces.
	IsFinal_typeContext()
}

type Final_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinal_typeContext() *Final_typeContext {
	var p = new(Final_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_final_type
	return p
}

func InitEmptyFinal_typeContext(p *Final_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = FlexarParserRULE_final_type
}

func (*Final_typeContext) IsFinal_typeContext() {}

func NewFinal_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Final_typeContext {
	var p = new(Final_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = FlexarParserRULE_final_type

	return p
}

func (s *Final_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Final_typeContext) INT() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT, 0)
}

func (s *Final_typeContext) INT8() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT8, 0)
}

func (s *Final_typeContext) INT16() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT16, 0)
}

func (s *Final_typeContext) INT32() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT32, 0)
}

func (s *Final_typeContext) INT64() antlr.TerminalNode {
	return s.GetToken(FlexarParserINT64, 0)
}

func (s *Final_typeContext) UINT() antlr.TerminalNode {
	return s.GetToken(FlexarParserUINT, 0)
}

func (s *Final_typeContext) UINT8() antlr.TerminalNode {
	return s.GetToken(FlexarParserUINT8, 0)
}

func (s *Final_typeContext) UINT16() antlr.TerminalNode {
	return s.GetToken(FlexarParserUINT16, 0)
}

func (s *Final_typeContext) UINT32() antlr.TerminalNode {
	return s.GetToken(FlexarParserUINT32, 0)
}

func (s *Final_typeContext) UINT64() antlr.TerminalNode {
	return s.GetToken(FlexarParserUINT64, 0)
}

func (s *Final_typeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(FlexarParserFLOAT, 0)
}

func (s *Final_typeContext) FLOAT32() antlr.TerminalNode {
	return s.GetToken(FlexarParserFLOAT32, 0)
}

func (s *Final_typeContext) FLOAT64() antlr.TerminalNode {
	return s.GetToken(FlexarParserFLOAT64, 0)
}

func (s *Final_typeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(FlexarParserBOOL, 0)
}

func (s *Final_typeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(FlexarParserCHAR, 0)
}

func (s *Final_typeContext) STRING() antlr.TerminalNode {
	return s.GetToken(FlexarParserSTRING, 0)
}

func (s *Final_typeContext) INF() antlr.TerminalNode {
	return s.GetToken(FlexarParserINF, 0)
}

func (s *Final_typeContext) TUPLE() antlr.TerminalNode {
	return s.GetToken(FlexarParserTUPLE, 0)
}

func (s *Final_typeContext) MAP() antlr.TerminalNode {
	return s.GetToken(FlexarParserMAP, 0)
}

func (s *Final_typeContext) ERROR() antlr.TerminalNode {
	return s.GetToken(FlexarParserERROR, 0)
}

func (s *Final_typeContext) NULL() antlr.TerminalNode {
	return s.GetToken(FlexarParserNULL, 0)
}

func (s *Final_typeContext) ANY() antlr.TerminalNode {
	return s.GetToken(FlexarParserANY, 0)
}

func (s *Final_typeContext) NAME() antlr.TerminalNode {
	return s.GetToken(FlexarParserNAME, 0)
}

func (s *Final_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Final_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Final_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.EnterFinal_type(s)
	}
}

func (s *Final_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(FlexarListener); ok {
		listenerT.ExitFinal_type(s)
	}
}

func (s *Final_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case FlexarVisitor:
		return t.VisitFinal_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *FlexarParser) Final_type() (localctx IFinal_typeContext) {
	localctx = NewFinal_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, FlexarParserRULE_final_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-42)) & ^0x3f) == 0 && ((int64(1)<<(_la-42))&71303167) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *FlexarParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 33:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 39:
		var t *And_expressionContext = nil
		if localctx != nil {
			t = localctx.(*And_expressionContext)
		}
		return p.And_expression_Sempred(t, predIndex)

	case 40:
		var t *Or_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Or_expressionContext)
		}
		return p.Or_expression_Sempred(t, predIndex)

	case 41:
		var t *Xor_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Xor_expressionContext)
		}
		return p.Xor_expression_Sempred(t, predIndex)

	case 43:
		var t *Expression_mathContext = nil
		if localctx != nil {
			t = localctx.(*Expression_mathContext)
		}
		return p.Expression_math_Sempred(t, predIndex)

	case 44:
		var t *Term_mathContext = nil
		if localctx != nil {
			t = localctx.(*Term_mathContext)
		}
		return p.Term_math_Sempred(t, predIndex)

	case 45:
		var t *Factor_mathContext = nil
		if localctx != nil {
			t = localctx.(*Factor_mathContext)
		}
		return p.Factor_math_Sempred(t, predIndex)

	case 46:
		var t *Bitwise_mathContext = nil
		if localctx != nil {
			t = localctx.(*Bitwise_mathContext)
		}
		return p.Bitwise_math_Sempred(t, predIndex)

	case 47:
		var t *Shift_mathContext = nil
		if localctx != nil {
			t = localctx.(*Shift_mathContext)
		}
		return p.Shift_math_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *FlexarParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 7)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) And_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Or_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Xor_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Expression_math_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Term_math_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Factor_math_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Bitwise_math_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *FlexarParser) Shift_math_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
